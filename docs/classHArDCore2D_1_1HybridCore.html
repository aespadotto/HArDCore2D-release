<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: HArDCore2D::HybridCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>HArDCore2D</b></li><li class="navelem"><a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHArDCore2D_1_1HybridCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HArDCore2D::HybridCore Class Reference<div class="ingroups"><a class="el" href="group__HybridCore.html">HybridCore</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="memItemLeft" align="right" valign="top"><a id="a4b9c53f6ec13dc9e73f5cdc5c8ae782b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">cell_basis_type</a> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="memdesc:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a4b9c53f6ec13dc9e73f5cdc5c8ae782b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="memItemLeft" align="right" valign="top"><a id="a41350d7c3ac5a5a5e932348d2c9d0750"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">cell_gradient_type</a> = std::function&lt; Eigen::Vector2d(double, double)&gt;</td></tr>
<tr class="memdesc:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for gradients of cell basis <br /></td></tr>
<tr class="separator:a41350d7c3ac5a5a5e932348d2c9d0750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3231c1356e797daaa3476ff1fa4154"><td class="memItemLeft" align="right" valign="top"><a id="a9e3231c1356e797daaa3476ff1fa4154"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9e3231c1356e797daaa3476ff1fa4154">edge_basis_type</a> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="memdesc:a9e3231c1356e797daaa3476ff1fa4154"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for edge basis <br /></td></tr>
<tr class="separator:a9e3231c1356e797daaa3476ff1fa4154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="memItemLeft" align="right" valign="top"><a id="ad9a6cc8ee2f9d26c936c5c61c358b538"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ad9a6cc8ee2f9d26c936c5c61c358b538">tensor_function_type</a> = std::function&lt; Eigen::Matrix2d(double, double)&gt;</td></tr>
<tr class="memdesc:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for 2D tensors basis <br /></td></tr>
<tr class="separator:ad9a6cc8ee2f9d26c936c5c61c358b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4978b5ad1f20f152357e94ffa94bfa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#af4978b5ad1f20f152357e94ffa94bfa9">HybridCore</a> (const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *mesh_ptr, const size_t <a class="el" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a>, const size_t <a class="el" href="group__HybridCore.html#ga816cd87658b200d1ea32d2c4fefd5c6e">L</a>, const std::string choice_basis=&quot;Mon&quot;)</td></tr>
<tr class="memdesc:af4978b5ad1f20f152357e94ffa94bfa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions.  <a href="#af4978b5ad1f20f152357e94ffa94bfa9">More...</a><br /></td></tr>
<tr class="separator:af4978b5ad1f20f152357e94ffa94bfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bdc59d150566e1b992058031509d2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aa2bdc59d150566e1b992058031509d2f">dim_Pcell</a> (const size_t m) const</td></tr>
<tr class="memdesc:aa2bdc59d150566e1b992058031509d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 2-variate polynomials up to degree m.  <a href="#aa2bdc59d150566e1b992058031509d2f">More...</a><br /></td></tr>
<tr class="separator:aa2bdc59d150566e1b992058031509d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ab0fb57313f27fb8b4a6e9747de1d5cfe">dim_Pedge</a> (const size_t m) const</td></tr>
<tr class="memdesc:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the size of the basis of 1-variate polynomials up to degree m.  <a href="#ab0fb57313f27fb8b4a6e9747de1d5cfe">More...</a><br /></td></tr>
<tr class="separator:ab0fb57313f27fb8b4a6e9747de1d5cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7006921a9e212784abf688f63a855a0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aa7006921a9e212784abf688f63a855a0">cell_monomial</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:aa7006921a9e212784abf688f63a855a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th monomial function of the cell iT.  <a href="#aa7006921a9e212784abf688f63a855a0">More...</a><br /></td></tr>
<tr class="separator:aa7006921a9e212784abf688f63a855a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0879fca63fe056f75bb0574584639b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a9e3231c1356e797daaa3476ff1fa4154">edge_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9a0879fca63fe056f75bb0574584639b">edge_monomial</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:a9a0879fca63fe056f75bb0574584639b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th monomial function of the edge iF.  <a href="#a9a0879fca63fe056f75bb0574584639b">More...</a><br /></td></tr>
<tr class="separator:a9a0879fca63fe056f75bb0574584639b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34242db07cc2b3c3b867d9e4580b634d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a34242db07cc2b3c3b867d9e4580b634d">cell_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a34242db07cc2b3c3b867d9e4580b634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the cell iT.  <a href="#a34242db07cc2b3c3b867d9e4580b634d">More...</a><br /></td></tr>
<tr class="separator:a34242db07cc2b3c3b867d9e4580b634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a9e3231c1356e797daaa3476ff1fa4154">edge_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a6b4feaeef7739a2e30fcf6c601fcf721">edge_basis</a> (size_t iF, size_t i) const</td></tr>
<tr class="memdesc:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th basis function of the edge iF.  <a href="#a6b4feaeef7739a2e30fcf6c601fcf721">More...</a><br /></td></tr>
<tr class="separator:a6b4feaeef7739a2e30fcf6c601fcf721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edb2fb02577f68744abb8a436381cf7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a0edb2fb02577f68744abb8a436381cf7">cell_monomials_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a0edb2fb02577f68744abb8a436381cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th monomial function of the cell iT.  <a href="#a0edb2fb02577f68744abb8a436381cf7">More...</a><br /></td></tr>
<tr class="separator:a0edb2fb02577f68744abb8a436381cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fc23b914623b90a2699ab4291e539"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a710fc23b914623b90a2699ab4291e539">cell_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:a710fc23b914623b90a2699ab4291e539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th basis function of the cell iT.  <a href="#a710fc23b914623b90a2699ab4291e539">More...</a><br /></td></tr>
<tr class="separator:a710fc23b914623b90a2699ab4291e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d70dcda8d8a56311b2d1eac4f7d306c"><td class="memItemLeft" align="right" valign="top">QuadratureRule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a5d70dcda8d8a56311b2d1eac4f7d306c">cell_qrule</a> (const size_t iT, const size_t doe, const bool force_split=false) const</td></tr>
<tr class="memdesc:a5d70dcda8d8a56311b2d1eac4f7d306c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quadrature rule of a given degree of exactness on a cell.  <a href="#a5d70dcda8d8a56311b2d1eac4f7d306c">More...</a><br /></td></tr>
<tr class="separator:a5d70dcda8d8a56311b2d1eac4f7d306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4158e234143fd956fd4038adf9097bc2"><td class="memItemLeft" align="right" valign="top">QuadratureRule&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a4158e234143fd956fd4038adf9097bc2">edge_qrule</a> (const size_t iE, const size_t doe) const</td></tr>
<tr class="memdesc:a4158e234143fd956fd4038adf9097bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a quadrature rule of a given degree of exactness on an edge.  <a href="#a4158e234143fd956fd4038adf9097bc2">More...</a><br /></td></tr>
<tr class="separator:a4158e234143fd956fd4038adf9097bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b46a742045262030431b73eb112f9c"><td class="memItemLeft" align="right" valign="top"><a id="a02b46a742045262030431b73eb112f9c"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a02b46a742045262030431b73eb112f9c">restr</a> (const Eigen::VectorXd &amp;Xh, size_t iT) const</td></tr>
<tr class="memdesc:a02b46a742045262030431b73eb112f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from a global vector Xh of unknowns the unknowns corresponding to cell iT. <br /></td></tr>
<tr class="separator:a02b46a742045262030431b73eb112f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memItemLeft" align="right" valign="top"><a id="a6c2a3d4fde899dde50fda5d97eafdc07"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a6c2a3d4fde899dde50fda5d97eafdc07">L2norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a6c2a3d4fde899dde50fda5d97eafdc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962007697ffc13367070f7c4bcbe875"><td class="memItemLeft" align="right" valign="top"><a id="a5962007697ffc13367070f7c4bcbe875"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a5962007697ffc13367070f7c4bcbe875">H1norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:a5962007697ffc13367070f7c4bcbe875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete H1 norm of a discrete function (using cell values) <br /></td></tr>
<tr class="separator:a5962007697ffc13367070f7c4bcbe875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8878fba08f008f5ecbaa69a9a084904"><td class="memItemLeft" align="right" valign="top"><a id="ac8878fba08f008f5ecbaa69a9a084904"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ac8878fba08f008f5ecbaa69a9a084904">Linf_edge</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:ac8878fba08f008f5ecbaa69a9a084904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute maximum of the coefficients on the edge basis functions. <br /></td></tr>
<tr class="separator:ac8878fba08f008f5ecbaa69a9a084904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga71c953efc96f467cb24faa1b60ee9bb2">interpolate</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolant in the discrete space of a continuous function.  <a href="group__HybridCore.html#ga71c953efc96f467cb24faa1b60ee9bb2">More...</a><br /></td></tr>
<tr class="separator:ga71c953efc96f467cb24faa1b60ee9bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c203c11a661933930a33335b0e2479"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#aa5c203c11a661933930a33335b0e2479">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</td></tr>
<tr class="separator:aa5c203c11a661933930a33335b0e2479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7cab97f874ee1c6debab251400d7a7"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9d7cab97f874ee1c6debab251400d7a7">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXXd &gt; &amp;F_quad, const std::vector&lt; Eigen::ArrayXXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; Eigen::Matrix2d &gt; L2Weight={}) const</td></tr>
<tr class="memdesc:a9d7cab97f874ee1c6debab251400d7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions.  <a href="#a9d7cab97f874ee1c6debab251400d7a7">More...</a><br /></td></tr>
<tr class="separator:a9d7cab97f874ee1c6debab251400d7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825c5d156026d465a2798389aa952b"><td class="memItemLeft" align="right" valign="top"><a id="a06825c5d156026d465a2798389aa952b"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a> (size_t iT) const</td></tr>
<tr class="memdesc:a06825c5d156026d465a2798389aa952b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights to compute cell unknowns from edge unknowns when l=-1. <br /></td></tr>
<tr class="separator:a06825c5d156026d465a2798389aa952b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf453b4f239a76fe7f21b02ac91e127c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#acf453b4f239a76fe7f21b02ac91e127c">basis_quad</a> (const std::string celledge, const size_t iTF, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</td></tr>
<tr class="memdesc:acf453b4f239a76fe7f21b02ac91e127c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes (cell or edge) basis functions at the given quadrature nodes.  <a href="#acf453b4f239a76fe7f21b02ac91e127c">More...</a><br /></td></tr>
<tr class="separator:acf453b4f239a76fe7f21b02ac91e127c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add794287f4bb49157a7b5f94a5ecb200"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#add794287f4bb49157a7b5f94a5ecb200">grad_basis_quad</a> (const size_t iT, const QuadratureRule quad, const size_t degree, const std::string type_basis=&quot;basis&quot;) const</td></tr>
<tr class="memdesc:add794287f4bb49157a7b5f94a5ecb200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$(\nabla \phi_i)_{i\in I}$" src="form_30.png"/> at the given quadrature nodes, where <img class="formulaInl" alt="$(\phi_i)_{i\in I}$" src="form_31.png"/> are the cell basis functions.  <a href="#add794287f4bb49157a7b5f94a5ecb200">More...</a><br /></td></tr>
<tr class="separator:add794287f4bb49157a7b5f94a5ecb200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="memItemLeft" align="right" valign="top"><a id="a58dd478934c1f5b65ae8b7df31e8ead4"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a58dd478934c1f5b65ae8b7df31e8ead4">evaluate_in_cell</a> (const Eigen::VectorXd XTF, size_t iT, double x, double y) const</td></tr>
<tr class="memdesc:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function in the cell iT at point (x,y) <br /></td></tr>
<tr class="separator:a58dd478934c1f5b65ae8b7df31e8ead4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6795e8bc0058be7e399b379333032c8"><td class="memItemLeft" align="right" valign="top"><a id="ae6795e8bc0058be7e399b379333032c8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ae6795e8bc0058be7e399b379333032c8">evaluate_in_edge</a> (const Eigen::VectorXd XTF, size_t iF, double x, double y) const</td></tr>
<tr class="memdesc:ae6795e8bc0058be7e399b379333032c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function on the edge iF at point (x,y) <br /></td></tr>
<tr class="separator:ae6795e8bc0058be7e399b379333032c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3337e9e6d16154e080e247b3fa43d72"><td class="memItemLeft" align="right" valign="top">
const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gab3337e9e6d16154e080e247b3fa43d72">get_mesh_ptr</a> () const</td></tr>
<tr class="memdesc:gab3337e9e6d16154e080e247b3fa43d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a pointer to the mesh <br /></td></tr>
<tr class="separator:gab3337e9e6d16154e080e247b3fa43d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf859b98dea34338c9e6376e975b131"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gadaf859b98dea34338c9e6376e975b131">K</a> () const</td></tr>
<tr class="memdesc:gadaf859b98dea34338c9e6376e975b131"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of edge unknowns <br /></td></tr>
<tr class="separator:gadaf859b98dea34338c9e6376e975b131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga816cd87658b200d1ea32d2c4fefd5c6e"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga816cd87658b200d1ea32d2c4fefd5c6e">L</a> () const</td></tr>
<tr class="memdesc:ga816cd87658b200d1ea32d2c4fefd5c6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">polynomial degree of cell unknowns <br /></td></tr>
<tr class="separator:ga816cd87658b200d1ea32d2c4fefd5c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa9fe846646c9e26f699364ac29631f6"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaaa9fe846646c9e26f699364ac29631f6">Ldeg</a> () const</td></tr>
<tr class="memdesc:gaaa9fe846646c9e26f699364ac29631f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">usually equal to L, but put at 0 if L=-1 <br /></td></tr>
<tr class="separator:gaaa9fe846646c9e26f699364ac29631f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf887b486ad0eea60382e306f1487b44a"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaf887b486ad0eea60382e306f1487b44a">ntotal_dofs</a> () const</td></tr>
<tr class="memdesc:gaf887b486ad0eea60382e306f1487b44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of degrees of freedom. <br /></td></tr>
<tr class="separator:gaf887b486ad0eea60382e306f1487b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab698480a3a9e9339d5c191549b817501"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gab698480a3a9e9339d5c191549b817501">nlocal_cell_dofs</a> () const</td></tr>
<tr class="memdesc:gab698480a3a9e9339d5c191549b817501"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom in each cell (dimension of polynomial space) <br /></td></tr>
<tr class="separator:gab698480a3a9e9339d5c191549b817501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86e6a3566cf506821606c8802a5f2364"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga86e6a3566cf506821606c8802a5f2364">ntotal_cell_dofs</a> () const</td></tr>
<tr class="memdesc:ga86e6a3566cf506821606c8802a5f2364"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom <br /></td></tr>
<tr class="separator:ga86e6a3566cf506821606c8802a5f2364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f1294e34e4daade19ad16981eaac15"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga41f1294e34e4daade19ad16981eaac15">nlocal_edge_dofs</a> () const</td></tr>
<tr class="memdesc:ga41f1294e34e4daade19ad16981eaac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of degrees of freedom on each edge (dimension of polynomial space) <br /></td></tr>
<tr class="separator:ga41f1294e34e4daade19ad16981eaac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0af0b8fa9bea07b9cfba8cbb1b50bed"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gac0af0b8fa9bea07b9cfba8cbb1b50bed">ntotal_edge_dofs</a> () const</td></tr>
<tr class="memdesc:gac0af0b8fa9bea07b9cfba8cbb1b50bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of edge degrees of freedom <br /></td></tr>
<tr class="separator:gac0af0b8fa9bea07b9cfba8cbb1b50bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c76303ee1dabc5c78f0bdd7a2c6aaa"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga95c76303ee1dabc5c78f0bdd7a2c6aaa">ninternal_edge_dofs</a> () const</td></tr>
<tr class="memdesc:ga95c76303ee1dabc5c78f0bdd7a2c6aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of edge degrees of freedom for internal edges <br /></td></tr>
<tr class="separator:ga95c76303ee1dabc5c78f0bdd7a2c6aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e7b0325c0966ec722fe8808048fb3ab"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga4e7b0325c0966ec722fe8808048fb3ab">nboundary_edge_dofs</a> () const</td></tr>
<tr class="memdesc:ga4e7b0325c0966ec722fe8808048fb3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of edge degrees of freedom for boundary edges <br /></td></tr>
<tr class="separator:ga4e7b0325c0966ec722fe8808048fb3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c23358c4ca7e485e8382c6b2761ad5"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga57c23358c4ca7e485e8382c6b2761ad5">nhighorder_dofs</a> () const</td></tr>
<tr class="memdesc:ga57c23358c4ca7e485e8382c6b2761ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of cell degrees of freedom with polynomials up to order k+1 <br /></td></tr>
<tr class="separator:ga57c23358c4ca7e485e8382c6b2761ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe520cbcf3d8212a503d51f11c13e5f"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gaffe520cbcf3d8212a503d51f11c13e5f">ngradient_dofs</a> () const</td></tr>
<tr class="memdesc:gaffe520cbcf3d8212a503d51f11c13e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">total number of degrees of freedom for gradients <br /></td></tr>
<tr class="separator:gaffe520cbcf3d8212a503d51f11c13e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga3c33c8cec55dbe2d8873e53fcd43d01f">quadrature_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over a cell. <br /></td></tr>
<tr class="separator:ga3c33c8cec55dbe2d8873e53fcd43d01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbf9c61f2d929331197ba971b52b8710"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gafbf9c61f2d929331197ba971b52b8710"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gafbf9c61f2d929331197ba971b52b8710">quadrature_over_edge</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:gafbf9c61f2d929331197ba971b52b8710"><td class="mdescLeft">&#160;</td><td class="mdescRight">To integrate a function over an edge. <br /></td></tr>
<tr class="separator:gafbf9c61f2d929331197ba971b52b8710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64ffbc44306e06018efe3cea5a62f652"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga64ffbc44306e06018efe3cea5a62f652"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga64ffbc44306e06018efe3cea5a62f652">integrate_over_cell</a> (const size_t iT, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga64ffbc44306e06018efe3cea5a62f652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over a cell. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:ga64ffbc44306e06018efe3cea5a62f652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03f276ea9c905d64662c39b7555d560c"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga03f276ea9c905d64662c39b7555d560c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga03f276ea9c905d64662c39b7555d560c">integrate_over_edge</a> (const size_t iF, const Function &amp;f) const</td></tr>
<tr class="memdesc:ga03f276ea9c905d64662c39b7555d560c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over an edge. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:ga03f276ea9c905d64662c39b7555d560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab058c4e54d1e33c49e537b8d0f602848"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gab058c4e54d1e33c49e537b8d0f602848"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#gab058c4e54d1e33c49e537b8d0f602848">integrate_over_domain</a> (const Function &amp;f) const</td></tr>
<tr class="memdesc:gab058c4e54d1e33c49e537b8d0f602848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrates a function over the domaine. Use with parcimony, expensive (re-compute quadratures) <br /></td></tr>
<tr class="separator:gab058c4e54d1e33c49e537b8d0f602848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e623d59fe09c23c4b714541e4aff5ea"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a4e623d59fe09c23c4b714541e4aff5ea">VertexValues</a> (const Eigen::VectorXd Xh, const std::string from_dofs)</td></tr>
<tr class="memdesc:a4e623d59fe09c23c4b714541e4aff5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a hybrid function, computes a vector of values at the vertices of the mesh.  <a href="#a4e623d59fe09c23c4b714541e4aff5ea">More...</a><br /></td></tr>
<tr class="separator:a4e623d59fe09c23c4b714541e4aff5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classHArDCore2D_1_1HybridCore.html">HybridCore</a> class provides convenient interfaces for performing integration over mesh cells and edges and handling polynomial basis functions The class also provides convenient interfaces for dealing with solutions to Hybrid High-Order schemes, such as the computation of integrals, norms and interpolants in the HHO space. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4978b5ad1f20f152357e94ffa94bfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4978b5ad1f20f152357e94ffa94bfa9">&#9670;&nbsp;</a></span>HybridCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HybridCore::HybridCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>choice_basis</em> = <code>&quot;Mon&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions. </p>
<p>The orthonormalisation comes at a cost in terms of manipulation of the basis functions. This should only be use when the polynomial degree is large and/or the cell is very distorted. However, in these cases, it can make a huge difference on the observed convergence rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A pointer to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the edge polynomials </td></tr>
    <tr><td class="paramname">L</td><td>The degree of the cell polynomials </td></tr>
    <tr><td class="paramname">choice_basis</td><td>"Mon" for monomials basis, "ON" for orthonormalised basis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acf453b4f239a76fe7f21b02ac91e127c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf453b4f239a76fe7f21b02ac91e127c">&#9670;&nbsp;</a></span>basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXd &gt; HybridCore::basis_quad </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>celledge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iTF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>type_basis</em> = <code>&quot;basis&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes (cell or edge) basis functions at the given quadrature nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>phi_quad[i] = array listing the nbq (=nb of quadrature nodes) values of phi_i at the quadrature nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">celledge</td><td>determines the type of basis function (cell or edge) we want the values of </td></tr>
    <tr><td class="paramname">iTF</td><td>global index of the cell/edge </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature nodes and weights on the cell/edge </td></tr>
    <tr><td class="paramname">degree</td><td>the maximum polynomial degree to consider </td></tr>
    <tr><td class="paramname">type_basis</td><td>optional argument to determine if we want on the monomial, or the basis functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34242db07cc2b3c3b867d9e4580b634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34242db07cc2b3c3b867d9e4580b634d">&#9670;&nbsp;</a></span>cell_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">HybridCore::cell_basis_type</a> &amp; HybridCore::cell_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the cell iT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a710fc23b914623b90a2699ab4291e539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710fc23b914623b90a2699ab4291e539">&#9670;&nbsp;</a></span>cell_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">HybridCore::cell_gradient_type</a> &amp; HybridCore::cell_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th basis function of the cell iT. </p>
<p>Note that the gradient functions are indexed the same as the basis functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant basis function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7006921a9e212784abf688f63a855a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7006921a9e212784abf688f63a855a0">&#9670;&nbsp;</a></span>cell_monomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a4b9c53f6ec13dc9e73f5cdc5c8ae782b">HybridCore::cell_basis_type</a> &amp; HybridCore::cell_monomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th monomial function of the cell iT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0edb2fb02577f68744abb8a436381cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edb2fb02577f68744abb8a436381cf7">&#9670;&nbsp;</a></span>cell_monomials_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a41350d7c3ac5a5a5e932348d2c9d0750">HybridCore::cell_gradient_type</a> &amp; HybridCore::cell_monomials_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th monomial function of the cell iT. </p>
<p>Note that the gradient functions are indexed the same as the monomial functions. In particular, this means that the first gradient function will always be identically zero, as it is the gradient of the constant monomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global cell number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d70dcda8d8a56311b2d1eac4f7d306c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d70dcda8d8a56311b2d1eac4f7d306c">&#9670;&nbsp;</a></span>cell_qrule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadratureRule HybridCore::cell_qrule </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>doe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>force_split</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a quadrature rule of a given degree of exactness on a cell. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature nodes and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>Global index of the cell </td></tr>
    <tr><td class="paramname">doe</td><td>Required degree of exactness </td></tr>
    <tr><td class="paramname">force_split</td><td>TRUE if we want the quadrature nodes to be computed by forcing the splitting of the cell into triangles based on its center of mass and edges (otherwise, for simple cells, quadrature nodes are computed by splitting in fewer triangles) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2bdc59d150566e1b992058031509d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2bdc59d150566e1b992058031509d2f">&#9670;&nbsp;</a></span>dim_Pcell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pcell </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 2-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0fb57313f27fb8b4a6e9747de1d5cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0fb57313f27fb8b4a6e9747de1d5cfe">&#9670;&nbsp;</a></span>dim_Pedge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t HybridCore::dim_Pedge </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the size of the basis of 1-variate polynomials up to degree m. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The maximum degree of the polynomial </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b4feaeef7739a2e30fcf6c601fcf721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4feaeef7739a2e30fcf6c601fcf721">&#9670;&nbsp;</a></span>edge_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a9e3231c1356e797daaa3476ff1fa4154">HybridCore::edge_basis_type</a> &amp; HybridCore::edge_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th basis function of the edge iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global edge number of the edge </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a0879fca63fe056f75bb0574584639b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0879fca63fe056f75bb0574584639b">&#9670;&nbsp;</a></span>edge_monomial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a9e3231c1356e797daaa3476ff1fa4154">HybridCore::edge_basis_type</a> &amp; HybridCore::edge_monomial </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a reference to the i'th monomial function of the edge iF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iF</td><td>The global edge number of the edge </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired monomial function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4158e234143fd956fd4038adf9097bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4158e234143fd956fd4038adf9097bc2">&#9670;&nbsp;</a></span>edge_qrule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QuadratureRule HybridCore::edge_qrule </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>doe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a quadrature rule of a given degree of exactness on an edge. </p>
<dl class="section return"><dt>Returns</dt><dd>list of quadrature nodes and weights </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iE</td><td>Global index of the edge </td></tr>
    <tr><td class="paramname">doe</td><td>Required degree of exactness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add794287f4bb49157a7b5f94a5ecb200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add794287f4bb49157a7b5f94a5ecb200">&#9670;&nbsp;</a></span>grad_basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXXd &gt; HybridCore::grad_basis_quad </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>type_basis</em> = <code>&quot;basis&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <img class="formulaInl" alt="$(\nabla \phi_i)_{i\in I}$" src="form_30.png"/> at the given quadrature nodes, where <img class="formulaInl" alt="$(\phi_i)_{i\in I}$" src="form_31.png"/> are the cell basis functions. </p>
<dl class="section return"><dt>Returns</dt><dd>dphi_quad[i]: array of size 2*nbq (where nbq=nb of quadrature nodes), with each column being <img class="formulaInl" alt="$\nabla \phi_i$" src="form_32.png"/> at the corresponding quadrature node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>global index of the cell </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature rules in the cell </td></tr>
    <tr><td class="paramname">degree</td><td>the maximum polynomial degree to consider </td></tr>
    <tr><td class="paramname">type_basis</td><td>optional argument to determine if we want on the monomial, or the basis functions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5c203c11a661933930a33335b0e2479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c203c11a661933930a33335b0e2479">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>L2weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the matrix of L2 products of two families (f_i) and (g_j) of functions (this is not really a Gram matrix, unless the two families are the same) </p><dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int f_i g_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_28.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Values of functions (f1,f2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">g_quad</td><td>Values of functions (g1,g2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions f_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns of the matrix - typically number of functions g_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #f&lt;=#g and f_i=g_i if i&lt;=#f) </td></tr>
    <tr><td class="paramname">L2weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;double&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d7cab97f874ee1c6debab251400d7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7cab97f874ee1c6debab251400d7a7">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HybridCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix2d &gt;&#160;</td>
          <td class="paramname"><em>L2Weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int F_i \cdot G_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_29.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F_quad</td><td>Values of functions (F1,F2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">G_quad</td><td>Values of functions (G1,G2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions F_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix - typically number of functions G_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #F&lt;=#G and F_i=G_i if i&lt;=#F) </td></tr>
    <tr><td class="paramname">L2Weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;Eigen::Matrix2d&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e623d59fe09c23c4b714541e4aff5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e623d59fe09c23c4b714541e4aff5ea">&#9670;&nbsp;</a></span>VertexValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HybridCore::VertexValues </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd&#160;</td>
          <td class="paramname"><em>Xh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a hybrid function, computes a vector of values at the vertices of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>hybrid function (cell and edge polynomials) </td></tr>
    <tr><td class="paramname">from_dofs</td><td>Type of unknowns to use: "cell" or "edge" </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/HybridCore/<a class="el" href="hybridcore_8hpp_source.html">hybridcore.hpp</a></li>
<li>src/HybridCore/hybridcore.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
