<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: BPNC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BPNC</div>  </div>
</div><!--header-->
<div class="contents">

<p>Tools to implement the Bubble Polytopal Non-Conforming method.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html">HArDCore2D::BPNC_StefanPME</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The vector Xh manipulated in the resolution has mixed components, corresponding either to the unknown u or to <img class="formulaInl" alt="$\zeta(u)$" src="form_33.png"/>, depending on the choice of weight of mass-lumping for the cell/edge unknowns. If no weight is put on the edges (resp. the cells), then the edge (resp. cell) unknowns represent <img class="formulaInl" alt="$\zeta(u)$" src="form_33.png"/>. Otherwise, they represent u.  <a href="classHArDCore2D_1_1BPNC__StefanPME.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1BPNCCore.html">HArDCore2D::BPNCCore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga85e80578aa553215feae11284549b354"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga85e80578aa553215feae11284549b354">HArDCore2D::BPNC_StefanPME::BPNC_StefanPME</a> (<a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> &amp;nc, <a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#aa07717e39892228c331b3cf3c29b086e">tensor_function_type</a> kappa, size_t deg_kappa, <a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#a233ff438d25c93b72498ce3b461c8623">source_function_type</a> source, <a class="el" href="classBoundaryConditions.html">BoundaryConditions</a> BC, <a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#ad0802f467317597f803c0dd45d26c3ba">solution_function_type</a> exact_solution, <a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#a33d159dc2e762c21926b85a21e38c5d8">grad_function_type</a> grad_exact_solution, <a class="el" href="classTestCaseNonLinearity.html#a3d8a5c89c517dd0d9c835b7441ee9b07">TestCaseNonLinearity::nonlinearity_function_type</a> zeta, double weight, std::string solver_type, std::ostream &amp;output=std::cout)</td></tr>
<tr class="memdesc:ga85e80578aa553215feae11284549b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the class.  <a href="#ga85e80578aa553215feae11284549b354">More...</a><br /></td></tr>
<tr class="separator:ga85e80578aa553215feae11284549b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8729ab99cd04c0ef4c6b2556805d1e8d"><td class="memItemLeft" align="right" valign="top"><a id="ga8729ab99cd04c0ef4c6b2556805d1e8d"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga8729ab99cd04c0ef4c6b2556805d1e8d">HArDCore2D::BPNC_StefanPME::solve</a> ()</td></tr>
<tr class="memdesc:ga8729ab99cd04c0ef4c6b2556805d1e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble and solve the scheme. <br /></td></tr>
<tr class="separator:ga8729ab99cd04c0ef4c6b2556805d1e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2805e0b077ec85e8530cf5e2b11be5"><td class="memItemLeft" align="right" valign="top"><a id="ga1d2805e0b077ec85e8530cf5e2b11be5"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga1d2805e0b077ec85e8530cf5e2b11be5">HArDCore2D::BPNC_StefanPME::apply_nonlinearity</a> (const Eigen::VectorXd &amp;Y, const std::string type) const</td></tr>
<tr class="memdesc:ga1d2805e0b077ec85e8530cf5e2b11be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute non-linearity on vector (depends if weight=0, weight=1 or weight (0,1) ) <br /></td></tr>
<tr class="separator:ga1d2805e0b077ec85e8530cf5e2b11be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54ab7a35ac7ccb83fc678aee96eb5dc3"><td class="memItemLeft" align="right" valign="top"><a id="ga54ab7a35ac7ccb83fc678aee96eb5dc3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga54ab7a35ac7ccb83fc678aee96eb5dc3">HArDCore2D::BPNC_StefanPME::L2_MassLumped</a> (const Eigen::VectorXd Xh) const</td></tr>
<tr class="memdesc:ga54ab7a35ac7ccb83fc678aee96eb5dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mass-lumped L2 norm of a function given by a vector. <br /></td></tr>
<tr class="separator:ga54ab7a35ac7ccb83fc678aee96eb5dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494151015dbd833a691e50f78966c82d"><td class="memItemLeft" align="right" valign="top"><a id="ga494151015dbd833a691e50f78966c82d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga494151015dbd833a691e50f78966c82d">HArDCore2D::BPNC_StefanPME::EnergyNorm</a> (const Eigen::VectorXd Xh) const</td></tr>
<tr class="memdesc:ga494151015dbd833a691e50f78966c82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete energy norm (associated to the diffusion operator) <br /></td></tr>
<tr class="separator:ga494151015dbd833a691e50f78966c82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade729cb0357bb3f3476c2335a37b822d"><td class="memItemLeft" align="right" valign="top"><a id="gade729cb0357bb3f3476c2335a37b822d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gade729cb0357bb3f3476c2335a37b822d">HArDCore2D::BPNC_StefanPME::get_assembly_time</a> () const</td></tr>
<tr class="memdesc:gade729cb0357bb3f3476c2335a37b822d"><td class="mdescLeft">&#160;</td><td class="mdescRight">cpu time to assemble the scheme <br /></td></tr>
<tr class="separator:gade729cb0357bb3f3476c2335a37b822d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90122c6a87891a16e7bc19edcfde175c"><td class="memItemLeft" align="right" valign="top"><a id="ga90122c6a87891a16e7bc19edcfde175c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga90122c6a87891a16e7bc19edcfde175c">HArDCore2D::BPNC_StefanPME::get_solving_time</a> () const</td></tr>
<tr class="memdesc:ga90122c6a87891a16e7bc19edcfde175c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cpu time to solve the scheme <br /></td></tr>
<tr class="separator:ga90122c6a87891a16e7bc19edcfde175c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cdc2dc9af6aa57d315e6660453641f7"><td class="memItemLeft" align="right" valign="top"><a id="ga1cdc2dc9af6aa57d315e6660453641f7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga1cdc2dc9af6aa57d315e6660453641f7">HArDCore2D::BPNC_StefanPME::get_itime</a> (size_t idx) const</td></tr>
<tr class="memdesc:ga1cdc2dc9af6aa57d315e6660453641f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">various intermediate assembly times <br /></td></tr>
<tr class="separator:ga1cdc2dc9af6aa57d315e6660453641f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb15277c1c88313e9e8e18186fea2b2f"><td class="memItemLeft" align="right" valign="top"><a id="gabb15277c1c88313e9e8e18186fea2b2f"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gabb15277c1c88313e9e8e18186fea2b2f">HArDCore2D::BPNC_StefanPME::get_solving_error</a> () const</td></tr>
<tr class="memdesc:gabb15277c1c88313e9e8e18186fea2b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">residual after solving the scheme <br /></td></tr>
<tr class="separator:gabb15277c1c88313e9e8e18186fea2b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063bc1a24f9fbe136809f447fc25a486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga063bc1a24f9fbe136809f447fc25a486">HArDCore2D::BPNCCore::BPNCCore</a> (const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *mesh_ptr, const size_t K, const size_t L, std::ostream &amp;output=std::cout)</td></tr>
<tr class="memdesc:ga063bc1a24f9fbe136809f447fc25a486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialise the <a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> class, and creates non-conforming basis functions (and gradients)  <a href="#ga063bc1a24f9fbe136809f447fc25a486">More...</a><br /></td></tr>
<tr class="separator:ga063bc1a24f9fbe136809f447fc25a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169de49549ae3c009c54c24d72d2e0ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3aa8544d9ea9ae31d70e65aaefb0e9c8">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga169de49549ae3c009c54c24d72d2e0ec">HArDCore2D::BPNCCore::nc_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga169de49549ae3c009c54c24d72d2e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th non-conforming basis function of the cell iT.  <a href="#ga169de49549ae3c009c54c24d72d2e0ec">More...</a><br /></td></tr>
<tr class="separator:ga169de49549ae3c009c54c24d72d2e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3e1f027c19acfc768851fbdbb00f2eec">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga967af6ae54aa35135ab8edb9cb94f1cf">HArDCore2D::BPNCCore::nc_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th non-conforming basis function of the cell iT.  <a href="#ga967af6ae54aa35135ab8edb9cb94f1cf">More...</a><br /></td></tr>
<tr class="separator:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554c5835189ff791d8db8f0e31c222dd"><td class="memItemLeft" align="right" valign="top">const VectorRd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga554c5835189ff791d8db8f0e31c222dd">HArDCore2D::BPNCCore::ml_node</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga554c5835189ff791d8db8f0e31c222dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i'th nodal point in cell iT (for mass lumping)  <a href="#ga554c5835189ff791d8db8f0e31c222dd">More...</a><br /></td></tr>
<tr class="separator:ga554c5835189ff791d8db8f0e31c222dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gadab9f7a9f6d42f729a8dce8e358e4d00">HArDCore2D::BPNCCore::nc_basis_quad</a> (const size_t iT, const QuadratureRule quad) const</td></tr>
<tr class="memdesc:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-conforming basis functions at the given quadrature nodes.  <a href="#gadab9f7a9f6d42f729a8dce8e358e4d00">More...</a><br /></td></tr>
<tr class="separator:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cc52dd5f725b057ec52cca573bf15f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gab7cc52dd5f725b057ec52cca573bf15f">HArDCore2D::BPNCCore::grad_nc_basis_quad</a> (const size_t iT, const QuadratureRule quad) const</td></tr>
<tr class="memdesc:gab7cc52dd5f725b057ec52cca573bf15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$(\nabla \phi_i^{nc})_{i\in I}$" src="form_35.png"/> at the quadrature nodes, where <img class="formulaInl" alt="$(\phi_i^{nc})_{i\in I}$" src="form_36.png"/> are the cell basis functions.  <a href="#gab7cc52dd5f725b057ec52cca573bf15f">More...</a><br /></td></tr>
<tr class="separator:gab7cc52dd5f725b057ec52cca573bf15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3150fe82adc0be190b698e1b17f6bc8"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gaa3150fe82adc0be190b698e1b17f6bc8">HArDCore2D::BPNCCore::gram_matrix</a> (const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</td></tr>
<tr class="separator:gaa3150fe82adc0be190b698e1b17f6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92e85c265e2138324347e02c2b7847f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gaf92e85c265e2138324347e02c2b7847f">HArDCore2D::BPNCCore::gram_matrix</a> (const std::vector&lt; Eigen::ArrayXXd &gt; &amp;F_quad, const std::vector&lt; Eigen::ArrayXXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; Eigen::Matrix2d &gt; L2Weight={}) const</td></tr>
<tr class="memdesc:gaf92e85c265e2138324347e02c2b7847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions.  <a href="#gaf92e85c265e2138324347e02c2b7847f">More...</a><br /></td></tr>
<tr class="separator:gaf92e85c265e2138324347e02c2b7847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memTemplParams" colspan="2"><a id="ga25153a400e70dd231c4c29f0f72f9f4d"></a>
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga25153a400e70dd231c4c29f0f72f9f4d">HArDCore2D::BPNCCore::nc_interpolate_moments</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a continuous function on the degrees of freedom, using the moments on the basis functions. The first ones are the cell DOFs (DimPoly&lt;Cell&gt;(1) for each cell), the last ones are the edge DOFs (one for each edge) <br /></td></tr>
<tr class="separator:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga28d174f3526b19d85e225b9db5f9de8e">HArDCore2D::BPNCCore::nc_interpolate_ml</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga28d174f3526b19d85e225b9db5f9de8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a continuous function on the degrees of freedom, using the moments on the basis functions associated to the edges and the nodal values (corresponding to mass-lumping) on the cell basis functions. The first ones are the cell DOFs (DimPoly&lt;Cell&gt;(1) for each cell), the last ones are the edge DOFs (one for each edge)  <a href="#ga28d174f3526b19d85e225b9db5f9de8e">More...</a><br /></td></tr>
<tr class="separator:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91a640f713f2f584b9280d7740f97da"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gad91a640f713f2f584b9280d7740f97da">HArDCore2D::BPNCCore::nc_restr</a> (const Eigen::VectorXd &amp;Xh, size_t iT) const</td></tr>
<tr class="memdesc:gad91a640f713f2f584b9280d7740f97da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from a global vector Xh of unknowns the non-conforming unknowns corresponding to cell iT.  <a href="#gad91a640f713f2f584b9280d7740f97da">More...</a><br /></td></tr>
<tr class="separator:gad91a640f713f2f584b9280d7740f97da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd34682af893a9c13dc8f60b9f2ca532"><td class="memItemLeft" align="right" valign="top"><a id="gafd34682af893a9c13dc8f60b9f2ca532"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gafd34682af893a9c13dc8f60b9f2ca532">HArDCore2D::BPNCCore::nc_L2norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:gafd34682af893a9c13dc8f60b9f2ca532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:gafd34682af893a9c13dc8f60b9f2ca532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="memItemLeft" align="right" valign="top"><a id="gabca2e8cbf4f01cddfa96124a07526a0e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gabca2e8cbf4f01cddfa96124a07526a0e">HArDCore2D::BPNCCore::nc_L2norm_ml</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of the mass-lumped discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="memItemLeft" align="right" valign="top"><a id="ga3d9e24f90636c4a8a5cac49f03e7ff59"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga3d9e24f90636c4a8a5cac49f03e7ff59">HArDCore2D::BPNCCore::nc_H1norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute broken H1 norm of a discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="memItemLeft" align="right" valign="top"><a id="ga7a82bab8fa4bfe4f99796db632d9411d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga7a82bab8fa4bfe4f99796db632d9411d">HArDCore2D::BPNCCore::nc_evaluate_in_cell</a> (const Eigen::VectorXd XTF, size_t iT, double x, double y) const</td></tr>
<tr class="memdesc:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a non-conforming discrete function in the cell iT at point (x,y) <br /></td></tr>
<tr class="separator:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3a632143dcb66992710d39cfb9ed42"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga2c3a632143dcb66992710d39cfb9ed42">HArDCore2D::BPNCCore::nc_VertexValues</a> (const Eigen::VectorXd Xh, const double weight=0)</td></tr>
<tr class="memdesc:ga2c3a632143dcb66992710d39cfb9ed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a non-conforming discrete function, computes a vector of values at the vertices of the mesh.  <a href="#ga2c3a632143dcb66992710d39cfb9ed42">More...</a><br /></td></tr>
<tr class="separator:ga2c3a632143dcb66992710d39cfb9ed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Tools to implement the Bubble Polytopal Non-Conforming method. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga85e80578aa553215feae11284549b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85e80578aa553215feae11284549b354">&#9670;&nbsp;</a></span>BPNC_StefanPME()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::BPNC_StefanPME::BPNC_StefanPME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> &amp;&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#aa07717e39892228c331b3cf3c29b086e">tensor_function_type</a>&#160;</td>
          <td class="paramname"><em>kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>deg_kappa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#a233ff438d25c93b72498ce3b461c8623">source_function_type</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBoundaryConditions.html">BoundaryConditions</a>&#160;</td>
          <td class="paramname"><em>BC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#ad0802f467317597f803c0dd45d26c3ba">solution_function_type</a>&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classHArDCore2D_1_1BPNC__StefanPME.html#a33d159dc2e762c21926b85a21e38c5d8">grad_function_type</a>&#160;</td>
          <td class="paramname"><em>grad_exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTestCaseNonLinearity.html#a3d8a5c89c517dd0d9c835b7441ee9b07">TestCaseNonLinearity::nonlinearity_function_type</a>&#160;</td>
          <td class="paramname"><em>zeta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nc</td><td>instance of the core nonconforming class (with basis functions, etc.) </td></tr>
    <tr><td class="paramname">kappa</td><td>diffusion tensor </td></tr>
    <tr><td class="paramname">deg_kappa</td><td>polynomial degree of the diffusion tensor </td></tr>
    <tr><td class="paramname">source</td><td>source term </td></tr>
    <tr><td class="paramname">BC</td><td>type of boundary conditions </td></tr>
    <tr><td class="paramname">exact_solution</td><td>exact solution </td></tr>
    <tr><td class="paramname">grad_exact_solution</td><td>gradient of the exact solution </td></tr>
    <tr><td class="paramname">zeta</td><td>function describing the nonlinearity </td></tr>
    <tr><td class="paramname">weight</td><td>proportion of weight (between 0 and 1) of mass-lumping on the edges </td></tr>
    <tr><td class="paramname">solver_type</td><td>type of solver to use for the global system (bicgstab at the moment) </td></tr>
    <tr><td class="paramname">output</td><td>optional argument for output of messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga063bc1a24f9fbe136809f447fc25a486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga063bc1a24f9fbe136809f447fc25a486">&#9670;&nbsp;</a></span>BPNCCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::BPNCCore::BPNCCore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor: initialise the <a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> class, and creates non-conforming basis functions (and gradients) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh_ptr</td><td>A pointer to the loaded mesh </td></tr>
    <tr><td class="paramname">K</td><td>The degree of the edge polynomials </td></tr>
    <tr><td class="paramname">L</td><td>The degree of the cell polynomials </td></tr>
    <tr><td class="paramname">output</td><td>Optional argument for specifying outputs of messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7cc52dd5f725b057ec52cca573bf15f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7cc52dd5f725b057ec52cca573bf15f">&#9670;&nbsp;</a></span>grad_nc_basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXXd &gt; HArDCore2D::BPNCCore::grad_nc_basis_quad </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute <img class="formulaInl" alt="$(\nabla \phi_i^{nc})_{i\in I}$" src="form_35.png"/> at the quadrature nodes, where <img class="formulaInl" alt="$(\phi_i^{nc})_{i\in I}$" src="form_36.png"/> are the cell basis functions. </p>
<dl class="section return"><dt>Returns</dt><dd>Dnc_phi_quad[i]: array of size 2*nbq (where nbq=nb of quadrature nodes), with each column being <img class="formulaInl" alt="$\nabla \phi_i^{nc}$" src="form_37.png"/> at the corresponding quadrature node </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>global index of the cell </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature rules in the cell </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3150fe82adc0be190b698e1b17f6bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3150fe82adc0be190b698e1b17f6bc8">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::BPNCCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>g_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>L2weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the matrix of L2 products of two families (f_i) and (g_j) of functions (this is not really a Gram matrix, unless the two families are the same) </p><dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int f_i g_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_28.png"/></dd></dl>
<p>Create the matrix of L2 products of two families (f_i) and (g_j) of functions (this is not really a Gram matrix, unless the two families are the same) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f_quad</td><td>Values of functions (f1,f2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">g_quad</td><td>Values of functions (g1,g2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions f_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of columns of the matrix - typically number of functions g_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #f&lt;=#g and f_i=g_i if i&lt;=#f) </td></tr>
    <tr><td class="paramname">L2weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;double&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf92e85c265e2138324347e02c2b7847f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf92e85c265e2138324347e02c2b7847f">&#9670;&nbsp;</a></span>gram_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::BPNCCore::gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>F_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::ArrayXXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>G_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Eigen::Matrix2d &gt;&#160;</td>
          <td class="paramname"><em>L2Weight</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions. </p>
<dl class="section return"><dt>Returns</dt><dd>The matrix <img class="formulaInl" alt="$(\int F_i \cdot G_j)_{i=1\ldots nrows; j=1\ldots ncols}$" src="form_29.png"/> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F_quad</td><td>Values of functions (F1,F2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">G_quad</td><td>Values of functions (G1,G2,...) at the quadrature nodes </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix - typically number of functions F_i (but could be less) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix - typically number of functions G_j (but could be less) </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature nodes for integration </td></tr>
    <tr><td class="paramname">sym</td><td>True if the matrix is pseudo-symmetric (that is, #F&lt;=#G and F_i=G_i if i&lt;=#F) </td></tr>
    <tr><td class="paramname">L2Weight</td><td>Optional weight for the L2 product. If provided, should be a std::vector&lt;Eigen::Matrix2d&gt; of the weight at the quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga554c5835189ff791d8db8f0e31c222dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga554c5835189ff791d8db8f0e31c222dd">&#9670;&nbsp;</a></span>ml_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VectorRd HArDCore2D::BPNCCore::ml_node </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the i'th nodal point in cell iT (for mass lumping) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired nodal point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga169de49549ae3c009c54c24d72d2e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga169de49549ae3c009c54c24d72d2e0ec">&#9670;&nbsp;</a></span>nc_basis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3aa8544d9ea9ae31d70e65aaefb0e9c8">BPNCCore::cell_basis_type</a> &amp; HArDCore2D::BPNCCore::nc_basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the i'th non-conforming basis function of the cell iT. </p>
<p>For i=DimPoly&lt;Cell&gt;(1) to nedge-1, nc_basis(iT,i) is the basis function associated with edge i (that is, product of all distances to all other edges, scaled to have an integral over edge i equal to 1). For i=0, ..., DimPoly&lt;Cell&gt;(1)-1 the basis function corresponds to 1, x, y, to which we subtract a linear combination of the basis functions corresponding to the edge in order to obtain basis functions with a zero integral on each edge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadab9f7a9f6d42f729a8dce8e358e4d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab9f7a9f6d42f729a8dce8e358e4d00">&#9670;&nbsp;</a></span>nc_basis_quad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; Eigen::ArrayXd &gt; HArDCore2D::BPNCCore::nc_basis_quad </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes non-conforming basis functions at the given quadrature nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>nc_phi_quad[i] = array listing the nbq (=nb of quadrature nodes) values of the nonconforming <img class="formulaInl" alt="$\phi^{nc}_i$" src="form_34.png"/> basis function at the quadrature nodes </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>global index of the cell/edge </td></tr>
    <tr><td class="paramname">quad</td><td>quadrature nodes and weights on the cell/edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga967af6ae54aa35135ab8edb9cb94f1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967af6ae54aa35135ab8edb9cb94f1cf">&#9670;&nbsp;</a></span>nc_gradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3e1f027c19acfc768851fbdbb00f2eec">BPNCCore::cell_gradient_type</a> &amp; HArDCore2D::BPNCCore::nc_gradient </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the gradient of the i'th non-conforming basis function of the cell iT. </p>
<p>The gradient functions are indexed the same as the basis functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iT</td><td>The global region number of the cell </td></tr>
    <tr><td class="paramname">i</td><td>The index of the desired basis function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28d174f3526b19d85e225b9db5f9de8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28d174f3526b19d85e225b9db5f9de8e">&#9670;&nbsp;</a></span>nc_interpolate_ml()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::BPNCCore::nc_interpolate_ml </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates a continuous function on the degrees of freedom, using the moments on the basis functions associated to the edges and the nodal values (corresponding to mass-lumping) on the cell basis functions. The first ones are the cell DOFs (DimPoly&lt;Cell&gt;(1) for each cell), the last ones are the edge DOFs (one for each edge) </p>
<dl class="section return"><dt>Returns</dt><dd>XTF = vector of coefficients on the basis functions; the first "DimPoly&lt;Cell&gt;(1)*nb cells" correspond to the first three basis functions in each cell (1, x, y with adjustments for the averages on the edges and mass-lumping points), and the last "nb edges" to the edge basis functions. </dd></dl>

</div>
</div>
<a id="gad91a640f713f2f584b9280d7740f97da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad91a640f713f2f584b9280d7740f97da">&#9670;&nbsp;</a></span>nc_restr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::BPNCCore::nc_restr </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>Xh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract from a global vector Xh of unknowns the non-conforming unknowns corresponding to cell iT. </p>
<dl class="section return"><dt>Returns</dt><dd>XTF = vector of coefficients on the basis functions; the first "DimPoly&lt;Cell&gt;(1)*nb cells" correspond to the first three basis functions in each cell (1, x, y with adjustments for the averages on the edges and mass-lumping points), and the last "nb edges" to the edge basis functions. </dd></dl>

</div>
</div>
<a id="ga2c3a632143dcb66992710d39cfb9ed42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c3a632143dcb66992710d39cfb9ed42">&#9670;&nbsp;</a></span>nc_VertexValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::BPNCCore::nc_VertexValues </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXd&#160;</td>
          <td class="paramname"><em>Xh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From a non-conforming discrete function, computes a vector of values at the vertices of the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Xh</td><td>non-conforming function (coefficients on basis) </td></tr>
    <tr><td class="paramname">weight</td><td>weight put on the edge values when evaluating the functions at the vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
