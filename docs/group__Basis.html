<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: Basis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Basis</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes and functions for polynomial basis creation and manipulation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">HArDCore2D::MonomialScalarBasisCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on a cell.  <a href="classHArDCore2D_1_1MonomialScalarBasisCell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">HArDCore2D::MonomialScalarBasisEdge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar monomial basis on an edge.  <a href="classHArDCore2D_1_1MonomialScalarBasisEdge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1Family.html">HArDCore2D::Family&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1TensorizedVectorFamily.html">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">HArDCore2D::ShiftedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">HArDCore2D::RestrictedBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1GradientBasis.html">HArDCore2D::GradientBasis&lt; BasisType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, BasisFunction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basis evaluation traits. Only specializations are meaningful.  <a href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Function_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Gradient_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Curl_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits_3_01BasisType_00_01Divergence_01_4.html">HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7f900870c2d2fad52b58a784576b2bfc"><td class="memItemLeft" align="right" valign="top"><a id="ga7f900870c2d2fad52b58a784576b2bfc"></a>
typedef Eigen::Matrix2d&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MatrixRd</b></td></tr>
<tr class="separator:ga7f900870c2d2fad52b58a784576b2bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b59ab7a013fef73321867484e13e2f3"><td class="memItemLeft" align="right" valign="top"><a id="ga2b59ab7a013fef73321867484e13e2f3"></a>
typedef Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::VectorRd</b></td></tr>
<tr class="separator:ga2b59ab7a013fef73321867484e13e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc880baa1a6163014c7f37345bf8ac6"><td class="memItemLeft" align="right" valign="top"><a id="ga2bc880baa1a6163014c7f37345bf8ac6"></a>
typedef Eigen::Vector2i&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::VectorZd</b></td></tr>
<tr class="separator:ga2bc880baa1a6163014c7f37345bf8ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memTemplParams" colspan="2"><a id="ga41970d25ff5ffdc77e1368ee5ce03bd4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">HArDCore2D::BasisQuad</a> = boost::multi_array&lt; T, 2 &gt;</td></tr>
<tr class="memdesc:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for a family of basis functions evaluated on quadrature nodes <br /></td></tr>
<tr class="separator:ga41970d25ff5ffdc77e1368ee5ce03bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e36fbf129c707351e533ee43579432"><td class="memTemplParams" colspan="2"><a id="gab1e36fbf129c707351e533ee43579432"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab1e36fbf129c707351e533ee43579432"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">HArDCore2D::FType</a> = std::function&lt; T(const VectorRd &amp;)&gt;</td></tr>
<tr class="memdesc:gab1e36fbf129c707351e533ee43579432"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for function of point. T is the type of value of the function <br /></td></tr>
<tr class="separator:gab1e36fbf129c707351e533ee43579432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a3ca323e3bd9968a90e8e3f9a3a6863"><td class="memItemLeft" align="right" valign="top"><a id="ga9a3ca323e3bd9968a90e8e3f9a3a6863"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::FunctionValue</b></td></tr>
<tr class="separator:ga9a3ca323e3bd9968a90e8e3f9a3a6863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad052f1f44cea110341eb1f86c2b732a9"><td class="memItemLeft" align="right" valign="top"><a id="gad052f1f44cea110341eb1f86c2b732a9"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::GradientValue</b></td></tr>
<tr class="separator:gad052f1f44cea110341eb1f86c2b732a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa9f1b9379558ebef24a3a0d99ef3fd"><td class="memItemLeft" align="right" valign="top"><a id="gaffa9f1b9379558ebef24a3a0d99ef3fd"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::CurlValue</b></td></tr>
<tr class="separator:gaffa9f1b9379558ebef24a3a0d99ef3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b25ab56ff038e78ea0f27fb1b1082f2"><td class="memItemLeft" align="right" valign="top"><a id="ga1b25ab56ff038e78ea0f27fb1b1082f2"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::DivergenceValue</b></td></tr>
<tr class="separator:ga1b25ab56ff038e78ea0f27fb1b1082f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga524ce4487f4f5163950b88a63d8e4025"><td class="memItemLeft" align="right" valign="top"><a id="ga524ce4487f4f5163950b88a63d8e4025"></a>
typedef <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::GeometricSupport</b></td></tr>
<tr class="separator:ga524ce4487f4f5163950b88a63d8e4025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf889760ab19dd5bd19e8780fe4378d25"><td class="memItemLeft" align="right" valign="top"><a id="gaf889760ab19dd5bd19e8780fe4378d25"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::FunctionValue</b></td></tr>
<tr class="separator:gaf889760ab19dd5bd19e8780fe4378d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac660ec4df6c23e7d383d2ccc5f06935b"><td class="memItemLeft" align="right" valign="top"><a id="gac660ec4df6c23e7d383d2ccc5f06935b"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::GradientValue</b></td></tr>
<tr class="separator:gac660ec4df6c23e7d383d2ccc5f06935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e51387f5ec1db65ed5f6a744026a6a2"><td class="memItemLeft" align="right" valign="top"><a id="ga0e51387f5ec1db65ed5f6a744026a6a2"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::CurlValue</b></td></tr>
<tr class="separator:ga0e51387f5ec1db65ed5f6a744026a6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ddce9d9620387e1273d1f71f7cd4f8f"><td class="memItemLeft" align="right" valign="top"><a id="ga9ddce9d9620387e1273d1f71f7cd4f8f"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::DivergenceValue</b></td></tr>
<tr class="separator:ga9ddce9d9620387e1273d1f71f7cd4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf296f0d9a155a2d4599512f96b3967cf"><td class="memItemLeft" align="right" valign="top"><a id="gaf296f0d9a155a2d4599512f96b3967cf"></a>
typedef <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::GeometricSupport</b></td></tr>
<tr class="separator:gaf296f0d9a155a2d4599512f96b3967cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a59e1b0aa753e65bb6553be665bdd"><td class="memItemLeft" align="right" valign="top"><a id="ga152a59e1b0aa753e65bb6553be665bdd"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga152a59e1b0aa753e65bb6553be665bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga063c30fe4fcd2174052072b1e255e7b3"><td class="memItemLeft" align="right" valign="top"><a id="ga063c30fe4fcd2174052072b1e255e7b3"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga063c30fe4fcd2174052072b1e255e7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeb4fac2009a5491c66a9f426b372b32"><td class="memItemLeft" align="right" valign="top"><a id="gabeb4fac2009a5491c66a9f426b372b32"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:gabeb4fac2009a5491c66a9f426b372b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26b41c8bd34a7bbd4543f931c27d7115"><td class="memItemLeft" align="right" valign="top"><a id="ga26b41c8bd34a7bbd4543f931c27d7115"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga26b41c8bd34a7bbd4543f931c27d7115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25780d2074b4184b02f14aed12cb7bd1"><td class="memItemLeft" align="right" valign="top"><a id="ga25780d2074b4184b02f14aed12cb7bd1"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga25780d2074b4184b02f14aed12cb7bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ec3e0805c4dd4a6758a94d04924520"><td class="memItemLeft" align="right" valign="top"><a id="ga55ec3e0805c4dd4a6758a94d04924520"></a>
typedef Eigen::Matrix&lt; double, N, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga55ec3e0805c4dd4a6758a94d04924520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e55037df352b512c181687d4526b11"><td class="memItemLeft" align="right" valign="top"><a id="ga03e55037df352b512c181687d4526b11"></a>
typedef Eigen::Matrix&lt; double, N, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::GradientValue</b></td></tr>
<tr class="separator:ga03e55037df352b512c181687d4526b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c7890d4b589d1e2cbe582445e638bb"><td class="memItemLeft" align="right" valign="top"><a id="ga88c7890d4b589d1e2cbe582445e638bb"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::CurlValue</b></td></tr>
<tr class="separator:ga88c7890d4b589d1e2cbe582445e638bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1dda1064d631768943c7658d2e69edd"><td class="memItemLeft" align="right" valign="top"><a id="gab1dda1064d631768943c7658d2e69edd"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::DivergenceValue</b></td></tr>
<tr class="separator:gab1dda1064d631768943c7658d2e69edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c8c80da131a654a1a91a43e379cc57"><td class="memItemLeft" align="right" valign="top"><a id="gad1c8c80da131a654a1a91a43e379cc57"></a>
typedef ScalarFamilyType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gad1c8c80da131a654a1a91a43e379cc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723910be19a99d8ce0273b83b8f5e867"><td class="memItemLeft" align="right" valign="top"><a id="ga723910be19a99d8ce0273b83b8f5e867"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga723910be19a99d8ce0273b83b8f5e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c735f6905189f7c0e959a4758d9ff4b"><td class="memItemLeft" align="right" valign="top"><a id="ga8c735f6905189f7c0e959a4758d9ff4b"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga8c735f6905189f7c0e959a4758d9ff4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga406ca8b5e2b929b24a7ac1f0f717ff4a"><td class="memItemLeft" align="right" valign="top"><a id="ga406ca8b5e2b929b24a7ac1f0f717ff4a"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga406ca8b5e2b929b24a7ac1f0f717ff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9555eb384f91b5a68a871632c839d9e3"><td class="memItemLeft" align="right" valign="top"><a id="ga9555eb384f91b5a68a871632c839d9e3"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga9555eb384f91b5a68a871632c839d9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677eacf2bedba936109ffd1f43593a7b"><td class="memItemLeft" align="right" valign="top"><a id="ga677eacf2bedba936109ffd1f43593a7b"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:ga677eacf2bedba936109ffd1f43593a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5772db07ac87c68788744dc652317540"><td class="memItemLeft" align="right" valign="top"><a id="ga5772db07ac87c68788744dc652317540"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga5772db07ac87c68788744dc652317540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd05335aff5beae7d23d274ccf95496"><td class="memItemLeft" align="right" valign="top"><a id="ga2fd05335aff5beae7d23d274ccf95496"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga2fd05335aff5beae7d23d274ccf95496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76c22157064e9c58e0e45c3dfcfc8e19"><td class="memItemLeft" align="right" valign="top"><a id="ga76c22157064e9c58e0e45c3dfcfc8e19"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:ga76c22157064e9c58e0e45c3dfcfc8e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga841d7df7cd3379bd3f774206dd1009d1"><td class="memItemLeft" align="right" valign="top"><a id="ga841d7df7cd3379bd3f774206dd1009d1"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga841d7df7cd3379bd3f774206dd1009d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1568c98b6dcfe1198d237669218e85c"><td class="memItemLeft" align="right" valign="top"><a id="gac1568c98b6dcfe1198d237669218e85c"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gac1568c98b6dcfe1198d237669218e85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88eba0d5ce79a279b6577d119c88442a"><td class="memItemLeft" align="right" valign="top"><a id="ga88eba0d5ce79a279b6577d119c88442a"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::FunctionValue</b></td></tr>
<tr class="separator:ga88eba0d5ce79a279b6577d119c88442a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ebfddada3978c4b571e667b939496c6"><td class="memItemLeft" align="right" valign="top"><a id="ga5ebfddada3978c4b571e667b939496c6"></a>
typedef Eigen::Matrix&lt; double, dimspace, dimspace &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::GradientValue</b></td></tr>
<tr class="separator:ga5ebfddada3978c4b571e667b939496c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2c823452962577abcb6f9176f1554fe"><td class="memItemLeft" align="right" valign="top"><a id="gac2c823452962577abcb6f9176f1554fe"></a>
typedef VectorRd&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::CurlValue</b></td></tr>
<tr class="separator:gac2c823452962577abcb6f9176f1554fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639a17eae62656583350d42bba42773c"><td class="memItemLeft" align="right" valign="top"><a id="ga639a17eae62656583350d42bba42773c"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::DivergenceValue</b></td></tr>
<tr class="separator:ga639a17eae62656583350d42bba42773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7aeabadc1694d72f9a7ec37924b86b7"><td class="memItemLeft" align="right" valign="top"><a id="gad7aeabadc1694d72f9a7ec37924b86b7"></a>
typedef BasisType::GeometricSupport&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::GeometricSupport</b></td></tr>
<tr class="separator:gad7aeabadc1694d72f9a7ec37924b86b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169e5809bf5bdd0b38087e155398861e"><td class="memItemLeft" align="right" valign="top"><a id="ga169e5809bf5bdd0b38087e155398861e"></a>
typedef BasisType::FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga169e5809bf5bdd0b38087e155398861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b10153f3e7e528d4e6508694d4bbea7"><td class="memItemLeft" align="right" valign="top"><a id="ga5b10153f3e7e528d4e6508694d4bbea7"></a>
typedef BasisType::GradientValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga5b10153f3e7e528d4e6508694d4bbea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80ce0c225d00d0530e83daa716962e26"><td class="memItemLeft" align="right" valign="top"><a id="ga80ce0c225d00d0530e83daa716962e26"></a>
typedef BasisType::CurlValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga80ce0c225d00d0530e83daa716962e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629fb65115831ee4fec373cac0698337"><td class="memItemLeft" align="right" valign="top"><a id="ga629fb65115831ee4fec373cac0698337"></a>
typedef BasisType::DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;::ReturnValue</b></td></tr>
<tr class="separator:ga629fb65115831ee4fec373cac0698337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga99c0a4ae66e5304b0bb7500c00f6e397"><td class="memItemLeft" align="right" valign="top"><a id="ga99c0a4ae66e5304b0bb7500c00f6e397"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TensorRankE</b> { <b>Scalar</b> = 0, 
<b>Vector</b> = 1, 
<b>Matrix</b> = 2
 }</td></tr>
<tr class="separator:ga99c0a4ae66e5304b0bb7500c00f6e397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21912c7c8daa962296cd7f608150d525"><td class="memItemLeft" align="right" valign="top"><a id="ga21912c7c8daa962296cd7f608150d525"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BasisFunctionE</b> { <b>Function</b>, 
<b>Gradient</b>, 
<b>Curl</b>, 
<b>Divergence</b>
 }</td></tr>
<tr class="separator:ga21912c7c8daa962296cd7f608150d525"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga077d11dc2b2d74d11b72f165dc8d033a">HArDCore2D::MonomialScalarBasisCell::MonomialScalarBasisCell</a> (const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;T, size_t degree)</td></tr>
<tr class="memdesc:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga077d11dc2b2d74d11b72f165dc8d033a">More...</a><br /></td></tr>
<tr class="separator:ga077d11dc2b2d74d11b72f165dc8d033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79a3220472fbc88d100be37ea1503d3e"><td class="memItemLeft" align="right" valign="top"><a id="ga79a3220472fbc88d100be37ea1503d3e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga79a3220472fbc88d100be37ea1503d3e">HArDCore2D::MonomialScalarBasisCell::dimension</a> () const</td></tr>
<tr class="memdesc:ga79a3220472fbc88d100be37ea1503d3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dimension of the basis. <br /></td></tr>
<tr class="separator:ga79a3220472fbc88d100be37ea1503d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="memItemLeft" align="right" valign="top"><a id="ga82562e20ba49b9e72e04c6a7660b1d3c"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga82562e20ba49b9e72e04c6a7660b1d3c">HArDCore2D::MonomialScalarBasisCell::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga82562e20ba49b9e72e04c6a7660b1d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34784e2233789bed6214488ff9e4166d"><td class="memItemLeft" align="right" valign="top"><a id="ga34784e2233789bed6214488ff9e4166d"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga34784e2233789bed6214488ff9e4166d">HArDCore2D::MonomialScalarBasisCell::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga34784e2233789bed6214488ff9e4166d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga34784e2233789bed6214488ff9e4166d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1794a48fbd89584ed844950e0057f513"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1794a48fbd89584ed844950e0057f513">HArDCore2D::MonomialScalarBasisEdge::MonomialScalarBasisEdge</a> (const <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a> &amp;E, size_t degree)</td></tr>
<tr class="memdesc:ga1794a48fbd89584ed844950e0057f513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga1794a48fbd89584ed844950e0057f513">More...</a><br /></td></tr>
<tr class="separator:ga1794a48fbd89584ed844950e0057f513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae546ece15c11ddb4382aa47c50fdd53c"><td class="memItemLeft" align="right" valign="top"><a id="gae546ece15c11ddb4382aa47c50fdd53c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gae546ece15c11ddb4382aa47c50fdd53c">HArDCore2D::MonomialScalarBasisEdge::dimension</a> () const</td></tr>
<tr class="memdesc:gae546ece15c11ddb4382aa47c50fdd53c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the basis. <br /></td></tr>
<tr class="separator:gae546ece15c11ddb4382aa47c50fdd53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ea5893997d96a77ea5a22d80777360"><td class="memItemLeft" align="right" valign="top"><a id="gaf3ea5893997d96a77ea5a22d80777360"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaf3ea5893997d96a77ea5a22d80777360">HArDCore2D::MonomialScalarBasisEdge::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gaf3ea5893997d96a77ea5a22d80777360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gaf3ea5893997d96a77ea5a22d80777360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fbc56b645a745e1ffef6995decc5cd"><td class="memItemLeft" align="right" valign="top"><a id="ga46fbc56b645a745e1ffef6995decc5cd"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga46fbc56b645a745e1ffef6995decc5cd">HArDCore2D::MonomialScalarBasisEdge::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga46fbc56b645a745e1ffef6995decc5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga46fbc56b645a745e1ffef6995decc5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga2e8f09ecc2cfd226ebb6539b34934d6a">HArDCore2D::Family&lt; BasisType &gt;::Family</a> (const BasisType &amp;basis, const Eigen::MatrixXd &amp;<a class="el" href="group__Basis.html#gaaf8f501609f30a03b0b167e381f6ac23">matrix</a>)</td></tr>
<tr class="memdesc:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga2e8f09ecc2cfd226ebb6539b34934d6a">More...</a><br /></td></tr>
<tr class="separator:ga2e8f09ecc2cfd226ebb6539b34934d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385bf99cf8c3888a150ed53f410ae39f"><td class="memItemLeft" align="right" valign="top"><a id="ga385bf99cf8c3888a150ed53f410ae39f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga385bf99cf8c3888a150ed53f410ae39f">HArDCore2D::Family&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga385bf99cf8c3888a150ed53f410ae39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension of the family. This is actually the number of functions in the family, not necessarily linearly independent. <br /></td></tr>
<tr class="separator:ga385bf99cf8c3888a150ed53f410ae39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="memItemLeft" align="right" valign="top"><a id="ga15a1f56b9bb54f849ebaf4a66f75907d"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga15a1f56b9bb54f849ebaf4a66f75907d">HArDCore2D::Family&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th function at point x. <br /></td></tr>
<tr class="separator:ga15a1f56b9bb54f849ebaf4a66f75907d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b9845ad5b44a743ae7e8223a897447"><td class="memItemLeft" align="right" valign="top"><a id="ga05b9845ad5b44a743ae7e8223a897447"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga05b9845ad5b44a743ae7e8223a897447">HArDCore2D::Family&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga05b9845ad5b44a743ae7e8223a897447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga05b9845ad5b44a743ae7e8223a897447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="memItemLeft" align="right" valign="top"><a id="ga9f44b487b46df0e9cf83b175ae0ae3b3"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9f44b487b46df0e9cf83b175ae0ae3b3">HArDCore2D::Family&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga9f44b487b46df0e9cf83b175ae0ae3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86a0fd0d5391607f156b3c27be6d7164"><td class="memItemLeft" align="right" valign="top"><a id="ga86a0fd0d5391607f156b3c27be6d7164"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga86a0fd0d5391607f156b3c27be6d7164">HArDCore2D::Family&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga86a0fd0d5391607f156b3c27be6d7164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th function at point x. <br /></td></tr>
<tr class="separator:ga86a0fd0d5391607f156b3c27be6d7164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf8f501609f30a03b0b167e381f6ac23"><td class="memItemLeft" align="right" valign="top"><a id="gaaf8f501609f30a03b0b167e381f6ac23"></a>
const Eigen::MatrixXd &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaaf8f501609f30a03b0b167e381f6ac23">HArDCore2D::Family&lt; BasisType &gt;::matrix</a> () const</td></tr>
<tr class="memdesc:gaaf8f501609f30a03b0b167e381f6ac23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coefficient matrix. <br /></td></tr>
<tr class="separator:gaaf8f501609f30a03b0b167e381f6ac23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f618ff125041ebcfb88db2f4373d37e"><td class="memItemLeft" align="right" valign="top"><a id="ga1f618ff125041ebcfb88db2f4373d37e"></a>
const BasisType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1f618ff125041ebcfb88db2f4373d37e">HArDCore2D::Family&lt; BasisType &gt;::ancestor</a> () const</td></tr>
<tr class="memdesc:ga1f618ff125041ebcfb88db2f4373d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ancestor. <br /></td></tr>
<tr class="separator:ga1f618ff125041ebcfb88db2f4373d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbbde5d4b671418870cbbd903a0a409b"><td class="memItemLeft" align="right" valign="top"><a id="gafbbde5d4b671418870cbbd903a0a409b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::TensorizedVectorFamily</b> (const ScalarFamilyType &amp;scalar_family)</td></tr>
<tr class="separator:gafbbde5d4b671418870cbbd903a0a409b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdcbe0043887c0aa46065409f1731a83"><td class="memItemLeft" align="right" valign="top"><a id="gabdcbe0043887c0aa46065409f1731a83"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gabdcbe0043887c0aa46065409f1731a83">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:gabdcbe0043887c0aa46065409f1731a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the family. <br /></td></tr>
<tr class="separator:gabdcbe0043887c0aa46065409f1731a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="memItemLeft" align="right" valign="top"><a id="ga52d9aaac677abb3a81b32c5542e55ea4"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga52d9aaac677abb3a81b32c5542e55ea4">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga52d9aaac677abb3a81b32c5542e55ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="memItemLeft" align="right" valign="top"><a id="ga46500da07e2cb4cfe8ead5ffe8dbc586"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga46500da07e2cb4cfe8ead5ffe8dbc586">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga46500da07e2cb4cfe8ead5ffe8dbc586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga187befd7daa85ec049e41706ea1d5de2"><td class="memItemLeft" align="right" valign="top"><a id="ga187befd7daa85ec049e41706ea1d5de2"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga187befd7daa85ec049e41706ea1d5de2">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga187befd7daa85ec049e41706ea1d5de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga187befd7daa85ec049e41706ea1d5de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="memItemLeft" align="right" valign="top"><a id="ga6e852fda44755e4ca0a8ffac94d97d16"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga6e852fda44755e4ca0a8ffac94d97d16">HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga6e852fda44755e4ca0a8ffac94d97d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb935c3f74623dbd29c124c0c6dc605e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gadb935c3f74623dbd29c124c0c6dc605e">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::ShiftedBasis</a> (const BasisType &amp;basis, const int shift)</td></tr>
<tr class="memdesc:gadb935c3f74623dbd29c124c0c6dc605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#gadb935c3f74623dbd29c124c0c6dc605e">More...</a><br /></td></tr>
<tr class="separator:gadb935c3f74623dbd29c124c0c6dc605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ebe98de6bd42447c4743c784e8c601"><td class="memItemLeft" align="right" valign="top"><a id="ga74ebe98de6bd42447c4743c784e8c601"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga74ebe98de6bd42447c4743c784e8c601">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga74ebe98de6bd42447c4743c784e8c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the basis. <br /></td></tr>
<tr class="separator:ga74ebe98de6bd42447c4743c784e8c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73529b85e8d087fdeee582e0744bf49a"><td class="memItemLeft" align="right" valign="top"><a id="ga73529b85e8d087fdeee582e0744bf49a"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga73529b85e8d087fdeee582e0744bf49a">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga73529b85e8d087fdeee582e0744bf49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga73529b85e8d087fdeee582e0744bf49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c06ac1c5648d70651308067df98c4c8"><td class="memItemLeft" align="right" valign="top"><a id="ga7c06ac1c5648d70651308067df98c4c8"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7c06ac1c5648d70651308067df98c4c8">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga7c06ac1c5648d70651308067df98c4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga7c06ac1c5648d70651308067df98c4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="memItemLeft" align="right" valign="top"><a id="ga7cb372f9d9384f30cecd1beb4b5d62b7"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7cb372f9d9384f30cecd1beb4b5d62b7">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga7cb372f9d9384f30cecd1beb4b5d62b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="memItemLeft" align="right" valign="top"><a id="ga84d8719be3260330c3c2e80dbf1b4eed"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga84d8719be3260330c3c2e80dbf1b4eed">HArDCore2D::ShiftedBasis&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga84d8719be3260330c3c2e80dbf1b4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga3c6a0bd9f6d2d6411762613b363f1716">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::RestrictedBasis</a> (const BasisType &amp;basis, const size_t &amp;<a class="el" href="group__Basis.html#ga5128f2da3cb58784d6ee7f4dffcacb90">dimension</a>)</td></tr>
<tr class="memdesc:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="group__Basis.html#ga3c6a0bd9f6d2d6411762613b363f1716">More...</a><br /></td></tr>
<tr class="separator:ga3c6a0bd9f6d2d6411762613b363f1716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="memItemLeft" align="right" valign="top"><a id="ga5128f2da3cb58784d6ee7f4dffcacb90"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5128f2da3cb58784d6ee7f4dffcacb90">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the dimension of the basis. <br /></td></tr>
<tr class="separator:ga5128f2da3cb58784d6ee7f4dffcacb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="memItemLeft" align="right" valign="top"><a id="ga1d2d6afdd27878c524490c2e4a9f0bc7"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1d2d6afdd27878c524490c2e4a9f0bc7">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga1d2d6afdd27878c524490c2e4a9f0bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="memItemLeft" align="right" valign="top"><a id="ga8e3093c0bd8ca48ef8d37d8f7d302fed"></a>
GradientValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga8e3093c0bd8ca48ef8d37d8f7d302fed">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::gradient</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the gradient of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga8e3093c0bd8ca48ef8d37d8f7d302fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="memItemLeft" align="right" valign="top"><a id="ga81e5a6c78223c5fe9a1e05d47a7798f1"></a>
CurlValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga81e5a6c78223c5fe9a1e05d47a7798f1">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::curl</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curl of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga81e5a6c78223c5fe9a1e05d47a7798f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa273301688a05d4f7e38cda0d1277212"><td class="memItemLeft" align="right" valign="top"><a id="gaa273301688a05d4f7e38cda0d1277212"></a>
DivergenceValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gaa273301688a05d4f7e38cda0d1277212">HArDCore2D::RestrictedBasis&lt; BasisType &gt;::divergence</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:gaa273301688a05d4f7e38cda0d1277212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the divergence of the i-th basis function at point x. <br /></td></tr>
<tr class="separator:gaa273301688a05d4f7e38cda0d1277212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="memItemLeft" align="right" valign="top"><a id="ga4177dd42cb8ac5499f6eae33965c0e69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga4177dd42cb8ac5499f6eae33965c0e69">HArDCore2D::GradientBasis&lt; BasisType &gt;::GradientBasis</a> (const BasisType &amp;basis)</td></tr>
<tr class="memdesc:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:ga4177dd42cb8ac5499f6eae33965c0e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="memItemLeft" align="right" valign="top"><a id="ga013a7a8c18e05623b1c9f6562f80c9e6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga013a7a8c18e05623b1c9f6562f80c9e6">HArDCore2D::GradientBasis&lt; BasisType &gt;::dimension</a> () const</td></tr>
<tr class="memdesc:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the dimension of the basis. <br /></td></tr>
<tr class="separator:ga013a7a8c18e05623b1c9f6562f80c9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e054975f7e1247ba66f08fa159dcf84"><td class="memItemLeft" align="right" valign="top"><a id="ga5e054975f7e1247ba66f08fa159dcf84"></a>
FunctionValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5e054975f7e1247ba66f08fa159dcf84">HArDCore2D::GradientBasis&lt; BasisType &gt;::function</a> (size_t i, const VectorRd &amp;x) const</td></tr>
<tr class="memdesc:ga5e054975f7e1247ba66f08fa159dcf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the i-th basis function at point x. <br /></td></tr>
<tr class="separator:ga5e054975f7e1247ba66f08fa159dcf84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b1bedb394bfa0843347da693760691"><td class="memItemLeft" align="right" valign="top"><a id="gad1b1bedb394bfa0843347da693760691"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Function &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gad1b1bedb394bfa0843347da693760691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1c26e922916f159b9e1eb123a0b53a"><td class="memItemLeft" align="right" valign="top"><a id="gafb1c26e922916f159b9e1eb123a0b53a"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Gradient &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gafb1c26e922916f159b9e1eb123a0b53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8e4677d16945866dc5ffc6d77de750e"><td class="memItemLeft" align="right" valign="top"><a id="gaa8e4677d16945866dc5ffc6d77de750e"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Curl &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gaa8e4677d16945866dc5ffc6d77de750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc363ebd4854186c0ed682d098158bc"><td class="memItemLeft" align="right" valign="top"><a id="gacbc363ebd4854186c0ed682d098158bc"></a>
static ReturnValue&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::detail::basis_evaluation_traits&lt; BasisType, Divergence &gt;::evaluate</b> (const BasisType &amp;basis, size_t i, const VectorRd &amp;x)</td></tr>
<tr class="separator:gacbc363ebd4854186c0ed682d098158bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687c3c9504c4b10c5a18654530980086"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga687c3c9504c4b10c5a18654530980086"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; BasisType, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const BasisType &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="memdesc:ga687c3c9504c4b10c5a18654530980086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic basis evaluation.  <a href="group__Basis.html#ga687c3c9504c4b10c5a18654530980086">More...</a><br /></td></tr>
<tr class="separator:ga687c3c9504c4b10c5a18654530980086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memTemplItemLeft" align="right" valign="top">static boost::multi_array&lt; typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt; <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt;, BasisFunction &gt;::ReturnValue, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga06cedf0c3440b94b9974922c72ea7c11">HArDCore2D::evaluate_quad&lt; BasisFunction &gt;::compute</a> (const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;basis, const QuadratureRule &amp;quad)</td></tr>
<tr class="separator:ga06cedf0c3440b94b9974922c72ea7c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">HArDCore2D::gram_schmidt</a> (boost::multi_array&lt; T, 2 &gt; &amp;basis_eval, const std::function&lt; double(size_t, size_t)&gt; &amp;inner_product)</td></tr>
<tr class="separator:ga9ea7809705d01c7cf6bca57a457a44a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5363b354f8dce20ca199459fe4074fda"><td class="memItemLeft" align="right" valign="top"><a id="ga5363b354f8dce20ca199459fe4074fda"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5363b354f8dce20ca199459fe4074fda">HArDCore2D::scalar_product</a> (const double &amp;x, const double &amp;y)</td></tr>
<tr class="memdesc:ga5363b354f8dce20ca199459fe4074fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two reals. <br /></td></tr>
<tr class="separator:ga5363b354f8dce20ca199459fe4074fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1566133b908e08f82d4598114bf10f3"><td class="memItemLeft" align="right" valign="top"><a id="gad1566133b908e08f82d4598114bf10f3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad1566133b908e08f82d4598114bf10f3">HArDCore2D::scalar_product</a> (const VectorRd &amp;x, const VectorRd &amp;y)</td></tr>
<tr class="memdesc:gad1566133b908e08f82d4598114bf10f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product between two vectors. <br /></td></tr>
<tr class="separator:gad1566133b908e08f82d4598114bf10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c6454782d8290f926940267271951bf"><td class="memItemLeft" align="right" valign="top">boost::multi_array&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga5c6454782d8290f926940267271951bf">HArDCore2D::scalar_product</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;basis_quad, const VectorRd &amp;v)</td></tr>
<tr class="separator:ga5c6454782d8290f926940267271951bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga3a5604879e905ecb08cbf4dda5d9a33c">HArDCore2D::l2_orthonormalize</a> (const BasisType &amp;basis, const QuadratureRule &amp;qr, boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><img class="formulaInl" alt="$L^2$" src="form_73.png"/>-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">gram_schmidt()</a> with the specific l2 inner product  <a href="group__Basis.html#ga3a5604879e905ecb08cbf4dda5d9a33c">More...</a><br /></td></tr>
<tr class="separator:ga3a5604879e905ecb08cbf4dda5d9a33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga29885facf8b5a576e7e0b609d1e3124f">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="separator:ga29885facf8b5a576e7e0b609d1e3124f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gafea1bf5033abb255fd6b73a3a30bf09e">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B1, const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="separator:gafea1bf5033abb255fd6b73a3a30bf09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memTemplParams" colspan="2">template&lt;typename FunctionValue &gt; </td></tr>
<tr class="memitem:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga0c65c290a977d9d35ae51d6edde392a8">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;B, const QuadratureRule &amp;qr)</td></tr>
<tr class="separator:ga0c65c290a977d9d35ae51d6edde392a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ea5a2eec9e5f2534c5ea34c6f8e973"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga56ea5a2eec9e5f2534c5ea34c6f8e973">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr)</td></tr>
<tr class="separator:ga56ea5a2eec9e5f2534c5ea34c6f8e973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4172a9ecfd889368855cf0715211e394"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga4172a9ecfd889368855cf0715211e394">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym)</td></tr>
<tr class="separator:ga4172a9ecfd889368855cf0715211e394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eda4d0d1366297ea84390f07c0a64ee"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga7eda4d0d1366297ea84390f07c0a64ee">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; double, 2 &gt; &amp;B1, const boost::multi_array&lt; double, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="separator:ga7eda4d0d1366297ea84390f07c0a64ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1183170eea0f44386e8a16ab1cdaf81a"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga1183170eea0f44386e8a16ab1cdaf81a">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const size_t nrows, const size_t ncols, const std::string sym)</td></tr>
<tr class="separator:ga1183170eea0f44386e8a16ab1cdaf81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe22102ff7c7e6dbeb63498396f2b54c"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gafe22102ff7c7e6dbeb63498396f2b54c">HArDCore2D::compute_gram_matrix</a> (const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B1, const boost::multi_array&lt; VectorRd, 2 &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="separator:gafe22102ff7c7e6dbeb63498396f2b54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad1f24a4a88d877b43abcd2df0592f1c2">HArDCore2D::integrate</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; T &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B, const QuadratureRule &amp;qr, size_t n_rows=0)</td></tr>
<tr class="memdesc:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of a given function against all functions from a family.  <a href="group__Basis.html#gad1f24a4a88d877b43abcd2df0592f1c2">More...</a><br /></td></tr>
<tr class="separator:gad1f24a4a88d877b43abcd2df0592f1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#gac450f5f0e9ac39ef61e8b3fda75c8931">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0, const std::string sym=&quot;nonsym&quot;)</td></tr>
<tr class="memdesc:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f phi_i, phi_j)  <a href="group__Basis.html#gac450f5f0e9ac39ef61e8b3fda75c8931">More...</a><br /></td></tr>
<tr class="separator:gac450f5f0e9ac39ef61e8b3fda75c8931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga167107aa2e92a2656ded2e8cafa7e59d">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;B2, const QuadratureRule &amp;qr, const std::string sym)</td></tr>
<tr class="memdesc:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f phi_i, phi_j)  <a href="group__Basis.html#ga167107aa2e92a2656ded2e8cafa7e59d">More...</a><br /></td></tr>
<tr class="separator:ga167107aa2e92a2656ded2e8cafa7e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga720d988c2c8cdf49c96687d63cc13d7e">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0)</td></tr>
<tr class="memdesc:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (f dot phi_i, phi_j)  <a href="group__Basis.html#ga720d988c2c8cdf49c96687d63cc13d7e">More...</a><br /></td></tr>
<tr class="separator:ga720d988c2c8cdf49c96687d63cc13d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ed4f83013c1957b10c920a57021406"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#gad8ed4f83013c1957b10c920a57021406">HArDCore2D::compute_weighted_gram_matrix</a> (const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;f, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;B1, const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;B2, const QuadratureRule &amp;qr, size_t n_rows=0, size_t n_cols=0)</td></tr>
<tr class="memdesc:gad8ed4f83013c1957b10c920a57021406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Gram-like matrix of integrals (phi_i, f dot phi_j)  <a href="group__Basis.html#gad8ed4f83013c1957b10c920a57021406">More...</a><br /></td></tr>
<tr class="separator:gad8ed4f83013c1957b10c920a57021406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memTemplParams" colspan="2">template&lt;typename BasisType &gt; </td></tr>
<tr class="memitem:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga650f15db9b781f0ad398e54d96a5ba39">HArDCore2D::l2_projection</a> (const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;f, const BasisType &amp;basis, QuadratureRule &amp;quad, const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;basis_quad)</td></tr>
<tr class="memdesc:ga650f15db9b781f0ad398e54d96a5ba39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2-projection of a function.  <a href="group__Basis.html#ga650f15db9b781f0ad398e54d96a5ba39">More...</a><br /></td></tr>
<tr class="separator:ga650f15db9b781f0ad398e54d96a5ba39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="memItemLeft" align="right" valign="top"><a id="ga99ab631a06b5d5a5f9f9673883c92ffe"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Basis.html#ga99ab631a06b5d5a5f9f9673883c92ffe">HArDCore2D::dimspace</a> = 2</td></tr>
<tr class="memdesc:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimension, and generic types for vector in correct dimension (makes it easier to translate a code between 2D and 3D) <br /></td></tr>
<tr class="separator:ga99ab631a06b5d5a5f9f9673883c92ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e7be051d395b2467975540f83d2665"><td class="memItemLeft" align="right" valign="top"><a id="gaa2e7be051d395b2467975540f83d2665"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::tensorRank</b> = Scalar</td></tr>
<tr class="separator:gaa2e7be051d395b2467975540f83d2665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0f6b3726df8161c638761d398a4aa4e"><td class="memItemLeft" align="right" valign="top"><a id="gac0f6b3726df8161c638761d398a4aa4e"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasFunction</b> = true</td></tr>
<tr class="separator:gac0f6b3726df8161c638761d398a4aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb26517e60d4ab841e21ca4a71a9c685"><td class="memItemLeft" align="right" valign="top"><a id="gadb26517e60d4ab841e21ca4a71a9c685"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasGradient</b> = true</td></tr>
<tr class="separator:gadb26517e60d4ab841e21ca4a71a9c685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1c39fee1ff92d9a2c6654dcff408b13"><td class="memItemLeft" align="right" valign="top"><a id="gaf1c39fee1ff92d9a2c6654dcff408b13"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasCurl</b> = false</td></tr>
<tr class="separator:gaf1c39fee1ff92d9a2c6654dcff408b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188cf489655ee1dcbf4fcf52060d457c"><td class="memItemLeft" align="right" valign="top"><a id="ga188cf489655ee1dcbf4fcf52060d457c"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisCell::hasDivergence</b> = false</td></tr>
<tr class="separator:ga188cf489655ee1dcbf4fcf52060d457c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad80154f0c46b6132980c3edf9378a0"><td class="memItemLeft" align="right" valign="top"><a id="gafad80154f0c46b6132980c3edf9378a0"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::tensorRank</b> = Scalar</td></tr>
<tr class="separator:gafad80154f0c46b6132980c3edf9378a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069544258c246a19a7574f22074fa4ee"><td class="memItemLeft" align="right" valign="top"><a id="ga069544258c246a19a7574f22074fa4ee"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasFunction</b> = true</td></tr>
<tr class="separator:ga069544258c246a19a7574f22074fa4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98b138ce500257ca01b37a6cc62cced7"><td class="memItemLeft" align="right" valign="top"><a id="ga98b138ce500257ca01b37a6cc62cced7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasGradient</b> = true</td></tr>
<tr class="separator:ga98b138ce500257ca01b37a6cc62cced7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga361073f6de474dfbc1c4aaa685220245"><td class="memItemLeft" align="right" valign="top"><a id="ga361073f6de474dfbc1c4aaa685220245"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasCurl</b> = false</td></tr>
<tr class="separator:ga361073f6de474dfbc1c4aaa685220245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga351c69a9068b7cae877fd1d4d369fabb"><td class="memItemLeft" align="right" valign="top"><a id="ga351c69a9068b7cae877fd1d4d369fabb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::MonomialScalarBasisEdge::hasDivergence</b> = false</td></tr>
<tr class="separator:ga351c69a9068b7cae877fd1d4d369fabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a0bf7e235f447facbea1470237a09e"><td class="memItemLeft" align="right" valign="top"><a id="gae7a0bf7e235f447facbea1470237a09e"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:gae7a0bf7e235f447facbea1470237a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadadcc5cd716933a3b1d54794b860bdcc"><td class="memItemLeft" align="right" valign="top"><a id="gadadcc5cd716933a3b1d54794b860bdcc"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:gadadcc5cd716933a3b1d54794b860bdcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39bd5582b1fa4926b4f6eb2143cb8b7"><td class="memItemLeft" align="right" valign="top"><a id="gae39bd5582b1fa4926b4f6eb2143cb8b7"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:gae39bd5582b1fa4926b4f6eb2143cb8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6193ca9c9f178fe6bfa2f0d85ba86b1"><td class="memItemLeft" align="right" valign="top"><a id="gaa6193ca9c9f178fe6bfa2f0d85ba86b1"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:gaa6193ca9c9f178fe6bfa2f0d85ba86b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4704c8206eb8a68ec251b10a9f90b54b"><td class="memItemLeft" align="right" valign="top"><a id="ga4704c8206eb8a68ec251b10a9f90b54b"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::Family&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:ga4704c8206eb8a68ec251b10a9f90b54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaada1d8a90047badc9910b9b312e6300e"><td class="memItemLeft" align="right" valign="top"><a id="gaada1d8a90047badc9910b9b312e6300e"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:gaada1d8a90047badc9910b9b312e6300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11bea467eab12156126ffc5d296ffecc"><td class="memItemLeft" align="right" valign="top"><a id="ga11bea467eab12156126ffc5d296ffecc"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasFunction</b> = ScalarFamilyType::hasFunction</td></tr>
<tr class="separator:ga11bea467eab12156126ffc5d296ffecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118c8e9bbbe5d63d2ce9575adf4e02eb"><td class="memItemLeft" align="right" valign="top"><a id="ga118c8e9bbbe5d63d2ce9575adf4e02eb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasGradient</b> = ScalarFamilyType::hasGradient</td></tr>
<tr class="separator:ga118c8e9bbbe5d63d2ce9575adf4e02eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67fc626998e10c80c40b9419e013e538"><td class="memItemLeft" align="right" valign="top"><a id="ga67fc626998e10c80c40b9419e013e538"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasDivergence</b> = ( ScalarFamilyType::hasGradient &amp;&amp; N==dimspace )</td></tr>
<tr class="separator:ga67fc626998e10c80c40b9419e013e538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440a12913a7f63653b9766e4180c5884"><td class="memItemLeft" align="right" valign="top"><a id="ga440a12913a7f63653b9766e4180c5884"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::TensorizedVectorFamily&lt; ScalarFamilyType, N &gt;::hasCurl</b> = ( ScalarFamilyType::hasGradient &amp;&amp; N==dimspace )</td></tr>
<tr class="separator:ga440a12913a7f63653b9766e4180c5884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga699c8451fd81d74301b1a2513ae34df0"><td class="memItemLeft" align="right" valign="top"><a id="ga699c8451fd81d74301b1a2513ae34df0"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:ga699c8451fd81d74301b1a2513ae34df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9b0469e3a9a1d2de82c3a0a5d362f0"><td class="memItemLeft" align="right" valign="top"><a id="ga0c9b0469e3a9a1d2de82c3a0a5d362f0"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:ga0c9b0469e3a9a1d2de82c3a0a5d362f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7af9068680c10bc140e0d7273e451c8"><td class="memItemLeft" align="right" valign="top"><a id="gaf7af9068680c10bc140e0d7273e451c8"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:gaf7af9068680c10bc140e0d7273e451c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac4d77a31c51c6a10406a87fb051bcb"><td class="memItemLeft" align="right" valign="top"><a id="gabac4d77a31c51c6a10406a87fb051bcb"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:gabac4d77a31c51c6a10406a87fb051bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6705a2937e7d47cadffd9a36e8a7371"><td class="memItemLeft" align="right" valign="top"><a id="gaf6705a2937e7d47cadffd9a36e8a7371"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::ShiftedBasis&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:gaf6705a2937e7d47cadffd9a36e8a7371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac0d24bac4b90d8f97562a6f7aa5de5"><td class="memItemLeft" align="right" valign="top"><a id="ga7ac0d24bac4b90d8f97562a6f7aa5de5"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::tensorRank</b> = BasisType::tensorRank</td></tr>
<tr class="separator:ga7ac0d24bac4b90d8f97562a6f7aa5de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace08c56ba0963f5148c3ae82bc820453"><td class="memItemLeft" align="right" valign="top"><a id="gace08c56ba0963f5148c3ae82bc820453"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasFunction</b> = BasisType::hasFunction</td></tr>
<tr class="separator:gace08c56ba0963f5148c3ae82bc820453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61cf97a1a52871887797bb46c15f0ba4"><td class="memItemLeft" align="right" valign="top"><a id="ga61cf97a1a52871887797bb46c15f0ba4"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasGradient</b> = BasisType::hasGradient</td></tr>
<tr class="separator:ga61cf97a1a52871887797bb46c15f0ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga929c9098450f73e3f7f5a315ac23b1fe"><td class="memItemLeft" align="right" valign="top"><a id="ga929c9098450f73e3f7f5a315ac23b1fe"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasCurl</b> = BasisType::hasCurl</td></tr>
<tr class="separator:ga929c9098450f73e3f7f5a315ac23b1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c2322e7e67b5ca1f562db511b1e6154"><td class="memItemLeft" align="right" valign="top"><a id="ga0c2322e7e67b5ca1f562db511b1e6154"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::RestrictedBasis&lt; BasisType &gt;::hasDivergence</b> = BasisType::hasDivergence</td></tr>
<tr class="separator:ga0c2322e7e67b5ca1f562db511b1e6154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acbb7bb95bd4c88fb8d5bb283df1013"><td class="memItemLeft" align="right" valign="top"><a id="ga1acbb7bb95bd4c88fb8d5bb283df1013"></a>
static const TensorRankE&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::tensorRank</b> = Vector</td></tr>
<tr class="separator:ga1acbb7bb95bd4c88fb8d5bb283df1013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db76edf9738f960e61862e962e6bd6f"><td class="memItemLeft" align="right" valign="top"><a id="ga3db76edf9738f960e61862e962e6bd6f"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasFunction</b> = true</td></tr>
<tr class="separator:ga3db76edf9738f960e61862e962e6bd6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8f1cede00f4c25346edd02b828a7aa4"><td class="memItemLeft" align="right" valign="top"><a id="gaa8f1cede00f4c25346edd02b828a7aa4"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasGradient</b> = false</td></tr>
<tr class="separator:gaa8f1cede00f4c25346edd02b828a7aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d63d9b4462f078073749a5cf69f9dd"><td class="memItemLeft" align="right" valign="top"><a id="ga94d63d9b4462f078073749a5cf69f9dd"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasCurl</b> = false</td></tr>
<tr class="separator:ga94d63d9b4462f078073749a5cf69f9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccec3fbf49f52c17ba38e873de7ac6ca"><td class="memItemLeft" align="right" valign="top"><a id="gaccec3fbf49f52c17ba38e873de7ac6ca"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>HArDCore2D::GradientBasis&lt; BasisType &gt;::hasDivergence</b> = false</td></tr>
<tr class="separator:gaccec3fbf49f52c17ba38e873de7ac6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes and functions for polynomial basis creation and manipulation. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga687c3c9504c4b10c5a18654530980086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687c3c9504c4b10c5a18654530980086">&#9670;&nbsp;</a></span>compute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;BasisType, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic basis evaluation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The basis </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06cedf0c3440b94b9974922c72ea7c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cedf0c3440b94b9974922c72ea7c11">&#9670;&nbsp;</a></span>compute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;BasisFunctionE BasisFunction&gt; </div>
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static boost::multi_array&lt;typename <a class="el" href="structHArDCore2D_1_1detail_1_1basis__evaluation__traits.html">detail::basis_evaluation_traits</a>&lt;<a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt;BasisType&gt;, BasisFunction&gt;::ReturnValue, 2&gt; <a class="el" href="structHArDCore2D_1_1evaluate__quad.html">HArDCore2D::evaluate_quad</a>&lt; BasisFunction &gt;::compute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; BasisType &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Evaluate a family at quadrature nodes. Same as '<a class="el" href="structHArDCore2D_1_1evaluate__quad.html">evaluate_quad</a>' but applied to a family given by an ancestor basis and a matrix (see class '<a class="el" href="classHArDCore2D_1_1Family.html">Family</a>') </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The family </td></tr>
    <tr><td class="paramname">quad</td><td>The quadrature rule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4172a9ecfd889368855cf0715211e394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4172a9ecfd889368855cf0715211e394">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for double-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7eda4d0d1366297ea84390f07c0a64ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eda4d0d1366297ea84390f07c0a64ee">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the double-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c65c290a977d9d35ae51d6edde392a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c65c290a977d9d35ae51d6edde392a8">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Gram matrix given the evaluation of one family of functions at quadrature nodes. Consists in calling the generic templated version with B1=B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29885facf8b5a576e7e0b609d1e3124f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29885facf8b5a576e7e0b609d1e3124f">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This templated function is very generic, and thus not the most efficient. More efficient overloads are provided for double- or Vector2d-valued families </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Number of rows of the matrix (nb of members of first family to consider) </td></tr>
    <tr><td class="paramname">ncols</td><td>Number of rows of the matrix (nn of members of second family to consider) </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafea1bf5033abb255fd6b73a3a30bf09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafea1bf5033abb255fd6b73a3a30bf09e">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version calls the generic one with nrows = nb of elements in family B1 and ncols = nb of elements in family B2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56ea5a2eec9e5f2534c5ea34c6f8e973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56ea5a2eec9e5f2534c5ea34c6f8e973">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; double, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given a family of vector-valued and one of scalar-valued functions by tensorizing the latter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family (to be tensorized) at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1183170eea0f44386e8a16ab1cdaf81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1183170eea0f44386e8a16ab1cdaf81a">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. This version is an overload for Vector2d-valued families, more efficient than the generic templated version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">nrows</td><td>Optional. Number of rows of the matrix (nb of members of first family to consider). </td></tr>
    <tr><td class="paramname">ncols</td><td>Optional. Number of rows of the matrix (nb of members of second family to consider). </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe22102ff7c7e6dbeb63498396f2b54c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe22102ff7c7e6dbeb63498396f2b54c">&#9670;&nbsp;</a></span>compute_gram_matrix() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Gram-like matrix given the evaluation of two families of functions at quadrature nodes. Consists in calling the Vector2d-valued version with nrows = nb of elements in B1, ncols = nb of elements in B2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">B1</td><td>First family at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td>Second family at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule used for evaluation </td></tr>
    <tr><td class="paramname">sym</td><td>Optional. "sym" to indicate that the matrix is symmetric (B1=B2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga167107aa2e92a2656ded2e8cafa7e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167107aa2e92a2656ded2e8cafa7e59d">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function. Posible types of U are MatrixRd and double - must be compatible with T </td></tr>
    <tr><td class="paramname">B1</td><td>First family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">B2</td><td>Second family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">sym</td><td>Argument if matrix is symmetric to increase efficiency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac450f5f0e9ac39ef61e8b3fda75c8931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac450f5f0e9ac39ef61e8b3fda75c8931">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>sym</em> = <code>&quot;nonsym&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function. Posible types of U are MatrixRd and double - must be compatible with T </td></tr>
    <tr><td class="paramname">B1</td><td>First family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">B2</td><td>Second family of basis functions at quadrature nodes. Posible types of T are VectorRd and double </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from first family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from second family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">sym</td><td>Optional argument if matrix is symmetric to increase efficiency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8ed4f83013c1957b10c920a57021406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ed4f83013c1957b10c920a57021406">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (phi_i, f dot phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function </td></tr>
    <tr><td class="paramname">B1</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of scalar basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of vector basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from scalar family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from vector family to be integrated against. Default integrates whole family </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga720d988c2c8cdf49c96687d63cc13d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga720d988c2c8cdf49c96687d63cc13d7e">&#9670;&nbsp;</a></span>compute_weighted_gram_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::compute_weighted_gram_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; VectorRd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Gram-like matrix of integrals (f dot phi_i, phi_j) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Weight function </td></tr>
    <tr><td class="paramname">B1</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of vector basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">B2</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of scalar basis functions at quadrature nodes </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of functions from vector family to be integrated against. Default integrates whole family </td></tr>
    <tr><td class="paramname">n_cols</td><td>Optional argument for number of functions from scalar family to be integrated against. Default integrates whole family </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e8f09ecc2cfd226ebb6539b34934d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e8f09ecc2cfd226ebb6539b34934d6a">&#9670;&nbsp;</a></span>Family()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1Family.html">HArDCore2D::Family</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1Family.html">Family</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>The basis in which the family is expressed </td></tr>
    <tr><td class="paramname">matrix</td><td>The coefficient matrix whose i-th line contains the coefficient of the expansion of the i-th function of the family in the basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ea7809705d01c7cf6bca57a457a44a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea7809705d01c7cf6bca57a457a44a4">&#9670;&nbsp;</a></span>gram_schmidt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd HArDCore2D::gram_schmidt </td>
          <td>(</td>
          <td class="paramtype">boost::multi_array&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; double(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>inner_product</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gram-Schmidt algorithm to ortonormalize a basis. The matrix <img class="formulaInl" alt="$M$" src="form_54.png"/> returned by this function gives the coefficients in the original basis of the orthonormalised basis. If <img class="formulaInl" alt="$(f_1,...,f_r)$" src="form_51.png"/> is the original basis, the orthonormalised basis is <img class="formulaInl" alt="$(\phi_1,...,\phi_r)$" src="form_71.png"/> where <img class="formulaInl" alt="$\phi_i = \sum_j M_{ij}f_j$" src="form_72.png"/>.</p>
<p>The function also modifies the variable basis_eval so that it contains the evaluation on at quadrature nodes of the new orthonormalised basis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_eval</td><td>Evaluations at quadrature nodes of the original basis. </td></tr>
    <tr><td class="paramname">inner_product</td><td>inner product (of two original basis functions) with respect to which we orthonormalise. This inner product must only depend on the basis functions through their values basis_eval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1f24a4a88d877b43abcd2df0592f1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1f24a4a88d877b43abcd2df0592f1c2">&#9670;&nbsp;</a></span>integrate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::integrate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#gab1e36fbf129c707351e533ee43579432">FType</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__Basis.html#ga41970d25ff5ffdc77e1368ee5ce03bd4">BasisQuad</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_rows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integral of a given function against all functions from a family. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to be integrated. Possible types of T are double and VectorRd </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classHArDCore2D_1_1Family.html">Family</a> of basis functions at quadrature nodes. Possible types of T are double and VectorRd </td></tr>
    <tr><td class="paramname">qr</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">n_rows</td><td>Optional argument for number of basis functions to be integrated. Default integrates all in the family. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a5604879e905ecb08cbf4dda5d9a33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a5604879e905ecb08cbf4dda5d9a33c">&#9670;&nbsp;</a></span>l2_orthonormalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt;BasisType&gt; HArDCore2D::l2_orthonormalize </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>qr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><img class="formulaInl" alt="$L^2$" src="form_73.png"/>-orthonormalization: simply consists in using <a class="el" href="group__Basis.html#ga9ea7809705d01c7cf6bca57a457a44a4">gram_schmidt()</a> with the specific l2 inner product </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>basis to orthonormalise </td></tr>
    <tr><td class="paramname">qr</td><td>quadrature rule for computing the l2 inner product </td></tr>
    <tr><td class="paramname">basis_quad</td><td>values of basis functions at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga650f15db9b781f0ad398e54d96a5ba39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga650f15db9b781f0ad398e54d96a5ba39">&#9670;&nbsp;</a></span>l2_projection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd HArDCore2D::l2_projection </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; typename BasisType::FunctionValue(const VectorRd &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QuadratureRule &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::multi_array&lt; typename BasisType::FunctionValue, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the L2-projection of a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to project </td></tr>
    <tr><td class="paramname">basis</td><td>Basis for the space on which we project </td></tr>
    <tr><td class="paramname">quad</td><td>Quadrature rule </td></tr>
    <tr><td class="paramname">basis_quad</td><td>Evaluation of the basis at quadrature nodes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga077d11dc2b2d74d11b72f165dc8d033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga077d11dc2b2d74d11b72f165dc8d033a">&#9670;&nbsp;</a></span>MonomialScalarBasisCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::MonomialScalarBasisCell::MonomialScalarBasisCell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Cell.html">Cell</a> &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>A mesh cell </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1794a48fbd89584ed844950e0057f513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1794a48fbd89584ed844950e0057f513">&#9670;&nbsp;</a></span>MonomialScalarBasisEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HArDCore2D::MonomialScalarBasisEdge::MonomialScalarBasisEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classHArDCore2D_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">E</td><td>A mesh edge </td></tr>
    <tr><td class="paramname">degree</td><td>The maximum polynomial degree to be considered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c6a0bd9f6d2d6411762613b363f1716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c6a0bd9f6d2d6411762613b363f1716">&#9670;&nbsp;</a></span>RestrictedBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">HArDCore2D::RestrictedBasis</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1RestrictedBasis.html">RestrictedBasis</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>A basis </td></tr>
    <tr><td class="paramname">dimension</td><td>The dimension of the restricted basis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c6454782d8290f926940267271951bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c6454782d8290f926940267271951bf">&#9670;&nbsp;</a></span>scalar_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::multi_array&lt; double, 2 &gt; HArDCore2D::scalar_product </td>
          <td>(</td>
          <td class="paramtype">const boost::multi_array&lt; VectorRd, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis_quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRd &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This overloading of the scalar_product function computes the scalar product between an evaluation of a basis and a constant vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis_quad</td><td>The basis evaluation </td></tr>
    <tr><td class="paramname">v</td><td>The vector to take the scalar product with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb935c3f74623dbd29c124c0c6dc605e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb935c3f74623dbd29c124c0c6dc605e">&#9670;&nbsp;</a></span>ShiftedBasis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BasisType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">HArDCore2D::ShiftedBasis</a>&lt; BasisType &gt;::<a class="el" href="classHArDCore2D_1_1ShiftedBasis.html">ShiftedBasis</a> </td>
          <td>(</td>
          <td class="paramtype">const BasisType &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>A basis </td></tr>
    <tr><td class="paramname">shift</td><td>The shift </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
