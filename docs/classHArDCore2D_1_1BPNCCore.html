<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HArD::Core2D: HArDCore2D::BPNCCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HArD::Core2D
   </div>
   <div id="projectbrief">Hybrid Arbitrary Degree::Core 2D - Library to implement 2D schemes with edge and cell polynomials as unknowns</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>HArDCore2D</b></li><li class="navelem"><a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classHArDCore2D_1_1BPNCCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">HArDCore2D::BPNCCore Class Reference<div class="ingroups"><a class="el" href="group__BPNC.html">BPNC</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bpnccore_8hpp_source.html">bpnccore.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for HArDCore2D::BPNCCore:</div>
<div class="dyncontent">
<div class="center"><img src="classHArDCore2D_1_1BPNCCore__inherit__graph.png" border="0" usemap="#HArDCore2D_1_1BPNCCore_inherit__map" alt="Inheritance graph"/></div>
<map name="HArDCore2D_1_1BPNCCore_inherit__map" id="HArDCore2D_1_1BPNCCore_inherit__map">
<area shape="rect" id="node2" href="classHArDCore2D_1_1HybridCore.html" title="HArDCore2D::HybridCore" alt="" coords="5,5,180,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for HArDCore2D::BPNCCore:</div>
<div class="dyncontent">
<div class="center"><img src="classHArDCore2D_1_1BPNCCore__coll__graph.png" border="0" usemap="#HArDCore2D_1_1BPNCCore_coll__map" alt="Collaboration graph"/></div>
<map name="HArDCore2D_1_1BPNCCore_coll__map" id="HArDCore2D_1_1BPNCCore_coll__map">
<area shape="rect" id="node2" href="classHArDCore2D_1_1HybridCore.html" title="HArDCore2D::HybridCore" alt="" coords="5,5,180,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3aa8544d9ea9ae31d70e65aaefb0e9c8"><td class="memItemLeft" align="right" valign="top"><a id="a3aa8544d9ea9ae31d70e65aaefb0e9c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3aa8544d9ea9ae31d70e65aaefb0e9c8">cell_basis_type</a> = std::function&lt; double(double, double)&gt;</td></tr>
<tr class="memdesc:a3aa8544d9ea9ae31d70e65aaefb0e9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a3aa8544d9ea9ae31d70e65aaefb0e9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1f027c19acfc768851fbdbb00f2eec"><td class="memItemLeft" align="right" valign="top"><a id="a3e1f027c19acfc768851fbdbb00f2eec"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3e1f027c19acfc768851fbdbb00f2eec">cell_gradient_type</a> = std::function&lt; VectorRd(double, double)&gt;</td></tr>
<tr class="memdesc:a3e1f027c19acfc768851fbdbb00f2eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for gradients of cell basis <br /></td></tr>
<tr class="separator:a3e1f027c19acfc768851fbdbb00f2eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classHArDCore2D_1_1HybridCore"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classHArDCore2D_1_1HybridCore')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classHArDCore2D_1_1HybridCore.html">HArDCore2D::HybridCore</a></td></tr>
<tr class="memitem:a66e8eccfa5bfc2788b2aec903bd64d4a inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a66e8eccfa5bfc2788b2aec903bd64d4a"></a>
typedef <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisCell.html">MonomialScalarBasisCell</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a66e8eccfa5bfc2788b2aec903bd64d4a">PolyCellBasisType</a></td></tr>
<tr class="memdesc:a66e8eccfa5bfc2788b2aec903bd64d4a inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for cell basis <br /></td></tr>
<tr class="separator:a66e8eccfa5bfc2788b2aec903bd64d4a inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76550d672e82b1b9e49ea90054b8cc6d inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a76550d672e82b1b9e49ea90054b8cc6d"></a>
typedef <a class="el" href="classHArDCore2D_1_1Family.html">Family</a>&lt; <a class="el" href="classHArDCore2D_1_1MonomialScalarBasisEdge.html">MonomialScalarBasisEdge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a76550d672e82b1b9e49ea90054b8cc6d">PolyEdgeBasisType</a></td></tr>
<tr class="memdesc:a76550d672e82b1b9e49ea90054b8cc6d inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">type for edge basis <br /></td></tr>
<tr class="separator:a76550d672e82b1b9e49ea90054b8cc6d inherit pub_types_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga063bc1a24f9fbe136809f447fc25a486"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga063bc1a24f9fbe136809f447fc25a486">BPNCCore</a> (const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *mesh_ptr, const size_t K, const size_t L, std::ostream &amp;output=std::cout)</td></tr>
<tr class="memdesc:ga063bc1a24f9fbe136809f447fc25a486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialise the <a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> class, and creates non-conforming basis functions (and gradients)  <a href="group__BPNC.html#ga063bc1a24f9fbe136809f447fc25a486">More...</a><br /></td></tr>
<tr class="separator:ga063bc1a24f9fbe136809f447fc25a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga169de49549ae3c009c54c24d72d2e0ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3aa8544d9ea9ae31d70e65aaefb0e9c8">cell_basis_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga169de49549ae3c009c54c24d72d2e0ec">nc_basis</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga169de49549ae3c009c54c24d72d2e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the i'th non-conforming basis function of the cell iT.  <a href="group__BPNC.html#ga169de49549ae3c009c54c24d72d2e0ec">More...</a><br /></td></tr>
<tr class="separator:ga169de49549ae3c009c54c24d72d2e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classHArDCore2D_1_1BPNCCore.html#a3e1f027c19acfc768851fbdbb00f2eec">cell_gradient_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga967af6ae54aa35135ab8edb9cb94f1cf">nc_gradient</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the gradient of the i'th non-conforming basis function of the cell iT.  <a href="group__BPNC.html#ga967af6ae54aa35135ab8edb9cb94f1cf">More...</a><br /></td></tr>
<tr class="separator:ga967af6ae54aa35135ab8edb9cb94f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554c5835189ff791d8db8f0e31c222dd"><td class="memItemLeft" align="right" valign="top">const VectorRd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga554c5835189ff791d8db8f0e31c222dd">ml_node</a> (size_t iT, size_t i) const</td></tr>
<tr class="memdesc:ga554c5835189ff791d8db8f0e31c222dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i'th nodal point in cell iT (for mass lumping)  <a href="group__BPNC.html#ga554c5835189ff791d8db8f0e31c222dd">More...</a><br /></td></tr>
<tr class="separator:ga554c5835189ff791d8db8f0e31c222dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gadab9f7a9f6d42f729a8dce8e358e4d00">nc_basis_quad</a> (const size_t iT, const QuadratureRule quad) const</td></tr>
<tr class="memdesc:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes non-conforming basis functions at the given quadrature nodes.  <a href="group__BPNC.html#gadab9f7a9f6d42f729a8dce8e358e4d00">More...</a><br /></td></tr>
<tr class="separator:gadab9f7a9f6d42f729a8dce8e358e4d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7cc52dd5f725b057ec52cca573bf15f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Eigen::ArrayXXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gab7cc52dd5f725b057ec52cca573bf15f">grad_nc_basis_quad</a> (const size_t iT, const QuadratureRule quad) const</td></tr>
<tr class="memdesc:gab7cc52dd5f725b057ec52cca573bf15f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute <img class="formulaInl" alt="$(\nabla \phi_i^{nc})_{i\in I}$" src="form_35.png"/> at the quadrature nodes, where <img class="formulaInl" alt="$(\phi_i^{nc})_{i\in I}$" src="form_36.png"/> are the cell basis functions.  <a href="group__BPNC.html#gab7cc52dd5f725b057ec52cca573bf15f">More...</a><br /></td></tr>
<tr class="separator:gab7cc52dd5f725b057ec52cca573bf15f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3150fe82adc0be190b698e1b17f6bc8"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gaa3150fe82adc0be190b698e1b17f6bc8">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXd &gt; &amp;f_quad, const std::vector&lt; Eigen::ArrayXd &gt; &amp;g_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; double &gt; L2weight={}) const</td></tr>
<tr class="separator:gaa3150fe82adc0be190b698e1b17f6bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92e85c265e2138324347e02c2b7847f"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gaf92e85c265e2138324347e02c2b7847f">gram_matrix</a> (const std::vector&lt; Eigen::ArrayXXd &gt; &amp;F_quad, const std::vector&lt; Eigen::ArrayXXd &gt; &amp;G_quad, const size_t &amp;nrows, const size_t &amp;ncols, const QuadratureRule &amp;quad, const bool &amp;sym, std::vector&lt; Eigen::Matrix2d &gt; L2Weight={}) const</td></tr>
<tr class="memdesc:gaf92e85c265e2138324347e02c2b7847f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded version of the previous one for vector-valued functions: the functions (F_i) and (G_j) are vector-valued functions.  <a href="group__BPNC.html#gaf92e85c265e2138324347e02c2b7847f">More...</a><br /></td></tr>
<tr class="separator:gaf92e85c265e2138324347e02c2b7847f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memTemplParams" colspan="2">
template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga25153a400e70dd231c4c29f0f72f9f4d">nc_interpolate_moments</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a continuous function on the degrees of freedom, using the moments on the basis functions. The first ones are the cell DOFs (DimPoly&lt;Cell&gt;(1) for each cell), the last ones are the edge DOFs (one for each edge) <br /></td></tr>
<tr class="separator:ga25153a400e70dd231c4c29f0f72f9f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga28d174f3526b19d85e225b9db5f9de8e">nc_interpolate_ml</a> (const Function &amp;f, size_t doe) const</td></tr>
<tr class="memdesc:ga28d174f3526b19d85e225b9db5f9de8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates a continuous function on the degrees of freedom, using the moments on the basis functions associated to the edges and the nodal values (corresponding to mass-lumping) on the cell basis functions. The first ones are the cell DOFs (DimPoly&lt;Cell&gt;(1) for each cell), the last ones are the edge DOFs (one for each edge)  <a href="group__BPNC.html#ga28d174f3526b19d85e225b9db5f9de8e">More...</a><br /></td></tr>
<tr class="separator:ga28d174f3526b19d85e225b9db5f9de8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad91a640f713f2f584b9280d7740f97da"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gad91a640f713f2f584b9280d7740f97da">nc_restr</a> (const Eigen::VectorXd &amp;Xh, size_t iT) const</td></tr>
<tr class="memdesc:gad91a640f713f2f584b9280d7740f97da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract from a global vector Xh of unknowns the non-conforming unknowns corresponding to cell iT.  <a href="group__BPNC.html#gad91a640f713f2f584b9280d7740f97da">More...</a><br /></td></tr>
<tr class="separator:gad91a640f713f2f584b9280d7740f97da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd34682af893a9c13dc8f60b9f2ca532"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gafd34682af893a9c13dc8f60b9f2ca532">nc_L2norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:gafd34682af893a9c13dc8f60b9f2ca532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:gafd34682af893a9c13dc8f60b9f2ca532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#gabca2e8cbf4f01cddfa96124a07526a0e">nc_L2norm_ml</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of the mass-lumped discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:gabca2e8cbf4f01cddfa96124a07526a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga3d9e24f90636c4a8a5cac49f03e7ff59">nc_H1norm</a> (const Eigen::VectorXd &amp;Xh) const</td></tr>
<tr class="memdesc:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute broken H1 norm of a discrete function (given by coefficients on the basis functions) <br /></td></tr>
<tr class="separator:ga3d9e24f90636c4a8a5cac49f03e7ff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="memItemLeft" align="right" valign="top">
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga7a82bab8fa4bfe4f99796db632d9411d">nc_evaluate_in_cell</a> (const Eigen::VectorXd XTF, size_t iT, double x, double y) const</td></tr>
<tr class="memdesc:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a non-conforming discrete function in the cell iT at point (x,y) <br /></td></tr>
<tr class="separator:ga7a82bab8fa4bfe4f99796db632d9411d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3a632143dcb66992710d39cfb9ed42"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BPNC.html#ga2c3a632143dcb66992710d39cfb9ed42">nc_VertexValues</a> (const Eigen::VectorXd Xh, const double weight=0)</td></tr>
<tr class="memdesc:ga2c3a632143dcb66992710d39cfb9ed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a non-conforming discrete function, computes a vector of values at the vertices of the mesh.  <a href="group__BPNC.html#ga2c3a632143dcb66992710d39cfb9ed42">More...</a><br /></td></tr>
<tr class="separator:ga2c3a632143dcb66992710d39cfb9ed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classHArDCore2D_1_1HybridCore"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classHArDCore2D_1_1HybridCore')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classHArDCore2D_1_1HybridCore.html">HArDCore2D::HybridCore</a></td></tr>
<tr class="memitem:ac6d3499861364085cc61cdde5c2c1241 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ac6d3499861364085cc61cdde5c2c1241">HybridCore</a> (const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *mesh_ptr, const int cell_deg, const size_t edge_deg, const bool use_threads=true, std::ostream &amp;output=std::cout)</td></tr>
<tr class="memdesc:ac6d3499861364085cc61cdde5c2c1241 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor: initialises the data structure with the given mesh, and desired polynomial degrees of the basis functions.  <a href="classHArDCore2D_1_1HybridCore.html#ac6d3499861364085cc61cdde5c2c1241">More...</a><br /></td></tr>
<tr class="separator:ac6d3499861364085cc61cdde5c2c1241 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e87aec0e4162f6307eef0c04216a6cd inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a8e87aec0e4162f6307eef0c04216a6cd"></a>
const <a class="el" href="classHArDCore2D_1_1Mesh.html">Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a8e87aec0e4162f6307eef0c04216a6cd">get_mesh</a> () const</td></tr>
<tr class="memdesc:a8e87aec0e4162f6307eef0c04216a6cd inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the mesh. <br /></td></tr>
<tr class="separator:a8e87aec0e4162f6307eef0c04216a6cd inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e2fbe7da3ab2425544b31fab6963f1 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a39e2fbe7da3ab2425544b31fab6963f1"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a39e2fbe7da3ab2425544b31fab6963f1">CellDegree</a> () const</td></tr>
<tr class="memdesc:a39e2fbe7da3ab2425544b31fab6963f1 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degree of cell polynomials. <br /></td></tr>
<tr class="separator:a39e2fbe7da3ab2425544b31fab6963f1 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2840c8c1113b389fbee0cbf3090cee1c inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a2840c8c1113b389fbee0cbf3090cee1c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>CellDegreePos</b> () const</td></tr>
<tr class="separator:a2840c8c1113b389fbee0cbf3090cee1c inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58775081d94627e58f88f6043ed87bec inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a58775081d94627e58f88f6043ed87bec"></a>
const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a58775081d94627e58f88f6043ed87bec">EdgeDegree</a> () const</td></tr>
<tr class="memdesc:a58775081d94627e58f88f6043ed87bec inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degree of edge polynomials. <br /></td></tr>
<tr class="separator:a58775081d94627e58f88f6043ed87bec inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3e4d056b781b2fff5e46466d47e0f3 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="afb3e4d056b781b2fff5e46466d47e0f3"></a>
const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a66e8eccfa5bfc2788b2aec903bd64d4a">PolyCellBasisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#afb3e4d056b781b2fff5e46466d47e0f3">CellBasis</a> (size_t iT) const</td></tr>
<tr class="memdesc:afb3e4d056b781b2fff5e46466d47e0f3 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cell basis for element with global index iT. <br /></td></tr>
<tr class="separator:afb3e4d056b781b2fff5e46466d47e0f3 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9394b577ae67c9aa2289095bfedc38e2 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a9394b577ae67c9aa2289095bfedc38e2"></a>
const <a class="el" href="classHArDCore2D_1_1HybridCore.html#a76550d672e82b1b9e49ea90054b8cc6d">PolyEdgeBasisType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9394b577ae67c9aa2289095bfedc38e2">EdgeBasis</a> (size_t iE) const</td></tr>
<tr class="memdesc:a9394b577ae67c9aa2289095bfedc38e2 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return edge basis for edge with global index iE. <br /></td></tr>
<tr class="separator:a9394b577ae67c9aa2289095bfedc38e2 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37ab89bf946e237821dd978f475b7c8 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ab37ab89bf946e237821dd978f475b7c8">L2norm</a> (const <a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a> &amp;Xh) const</td></tr>
<tr class="memdesc:ab37ab89bf946e237821dd978f475b7c8 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L2 norm of a discrete function (using cell values)  <a href="classHArDCore2D_1_1HybridCore.html#ab37ab89bf946e237821dd978f475b7c8">More...</a><br /></td></tr>
<tr class="separator:ab37ab89bf946e237821dd978f475b7c8 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6672e0691764ec5752eb1a9a7257792 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ad6672e0691764ec5752eb1a9a7257792">H1norm</a> (const <a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a> &amp;Xh) const</td></tr>
<tr class="memdesc:ad6672e0691764ec5752eb1a9a7257792 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute discrete H1 norm of a discrete function.  <a href="classHArDCore2D_1_1HybridCore.html#ad6672e0691764ec5752eb1a9a7257792">More...</a><br /></td></tr>
<tr class="separator:ad6672e0691764ec5752eb1a9a7257792 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6af50952aa59143ac364dd1dc4118e inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memTemplParams" colspan="2">template&lt;typename ContinuousFunction &gt; </td></tr>
<tr class="memitem:ga7d6af50952aa59143ac364dd1dc4118e inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HybridCore.html#ga7d6af50952aa59143ac364dd1dc4118e">interpolate</a> (const ContinuousFunction &amp;f, const int deg_cell, const size_t deg_edge, size_t doe) const</td></tr>
<tr class="memdesc:ga7d6af50952aa59143ac364dd1dc4118e inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the interpolant in the discrete space of a continuous function.  <a href="group__HybridCore.html#ga7d6af50952aa59143ac364dd1dc4118e">More...</a><br /></td></tr>
<tr class="separator:ga7d6af50952aa59143ac364dd1dc4118e inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06825c5d156026d465a2798389aa952b inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a06825c5d156026d465a2798389aa952b"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a06825c5d156026d465a2798389aa952b">compute_weights</a> (size_t iT) const</td></tr>
<tr class="memdesc:a06825c5d156026d465a2798389aa952b inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weights to get cell values from edge values when l=-1. <br /></td></tr>
<tr class="separator:a06825c5d156026d465a2798389aa952b inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c76abf42a1d56fbf863d8258690497c inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="a9c76abf42a1d56fbf863d8258690497c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a9c76abf42a1d56fbf863d8258690497c">evaluate_in_cell</a> (const <a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a> Xh, size_t iT, VectorRd x) const</td></tr>
<tr class="memdesc:a9c76abf42a1d56fbf863d8258690497c inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function in the cell iT at point x. <br /></td></tr>
<tr class="separator:a9c76abf42a1d56fbf863d8258690497c inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43816ad8a9a91f841fdb4cea0781f54 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top"><a id="ab43816ad8a9a91f841fdb4cea0781f54"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#ab43816ad8a9a91f841fdb4cea0781f54">evaluate_in_edge</a> (const <a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a> Xh, size_t iE, VectorRd x) const</td></tr>
<tr class="memdesc:ab43816ad8a9a91f841fdb4cea0781f54 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates a discrete function on the edge iE at point x. <br /></td></tr>
<tr class="separator:ab43816ad8a9a91f841fdb4cea0781f54 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d33ec0786b8127a161384ecf8f04018 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHArDCore2D_1_1HybridCore.html#a1d33ec0786b8127a161384ecf8f04018">VertexValues</a> (const <a class="el" href="classHArDCore2D_1_1UVector.html">UVector</a> Xh, const std::string from_dofs)</td></tr>
<tr class="memdesc:a1d33ec0786b8127a161384ecf8f04018 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="mdescLeft">&#160;</td><td class="mdescRight">From a hybrid function, computes a vector of values at the vertices of the mesh.  <a href="classHArDCore2D_1_1HybridCore.html#a1d33ec0786b8127a161384ecf8f04018">More...</a><br /></td></tr>
<tr class="separator:a1d33ec0786b8127a161384ecf8f04018 inherit pub_methods_classHArDCore2D_1_1HybridCore"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classHArDCore2D_1_1BPNCCore.html">BPNCCore</a> class provides basis functions for non-conforming schemes on generic polygonal meshes</p>
<p>If using this code in a scientific publication, please cite the reference for the BPNC:</p>
<p>Non-conforming finite elements on polytopal mesh, J. Droniou, R. Eymard, T. Gallouët and R. Herbin url: </p>
</div><hr/>The documentation for this class was generated from the following file:<ul>
<li>Schemes/BPNC/<a class="el" href="bpnccore_8hpp_source.html">bpnccore.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
